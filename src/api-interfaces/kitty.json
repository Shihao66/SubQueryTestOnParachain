{
    "modules": [
      {
        "name": "System",
        "storage": {
          "prefix": "System",
          "items": [
            {
              "name": "Account",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "AccountInfo",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The full account information for a particular account ID."
              ]
            },
            {
              "name": "ExtrinsicCount",
              "modifier": "Optional",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00",
              "docs": [
                " Total extrinsics count for the current block."
              ]
            },
            {
              "name": "BlockWeight",
              "modifier": "Default",
              "type": {
                "Plain": "ConsumedWeight"
              },
              "fallback": "0x000000000000000000000000000000000000000000000000",
              "docs": [
                " The current weight for the block."
              ]
            },
            {
              "name": "AllExtrinsicsLen",
              "modifier": "Optional",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00",
              "docs": [
                " Total length (in bytes) for all extrinsics put together, for the current block."
              ]
            },
            {
              "name": "BlockHash",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "BlockNumber",
                  "value": "Hash",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Map of block numbers to block hashes."
              ]
            },
            {
              "name": "ExtrinsicData",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "u32",
                  "value": "Bytes",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Extrinsics data for the current block (maps an extrinsic's index to its data)."
              ]
            },
            {
              "name": "Number",
              "modifier": "Default",
              "type": {
                "Plain": "BlockNumber"
              },
              "fallback": "0x00000000",
              "docs": [
                " The current block number being processed. Set by `execute_block`."
              ]
            },
            {
              "name": "ParentHash",
              "modifier": "Default",
              "type": {
                "Plain": "Hash"
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Hash of the previous block."
              ]
            },
            {
              "name": "Digest",
              "modifier": "Default",
              "type": {
                "Plain": "DigestOf"
              },
              "fallback": "0x00",
              "docs": [
                " Digest of the current block, also part of the block header."
              ]
            },
            {
              "name": "Events",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<EventRecord>"
              },
              "fallback": "0x00",
              "docs": [
                " Events deposited for the current block."
              ]
            },
            {
              "name": "EventCount",
              "modifier": "Default",
              "type": {
                "Plain": "EventIndex"
              },
              "fallback": "0x00000000",
              "docs": [
                " The number of events in the `Events<T>` list."
              ]
            },
            {
              "name": "EventTopics",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "Hash",
                  "value": "Vec<(BlockNumber,EventIndex)>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                " of events in the `<Events<T>>` list.",
                "",
                " All topic vectors have deterministic storage locations depending on the topic. This",
                " allows light-clients to leverage the changes trie storage tracking mechanism and",
                " in case of changes fetch the list of events of interest.",
                "",
                " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                " the `EventIndex` then in case if the topic has the same contents on the next block",
                " no notification will be triggered thus the event might be lost."
              ]
            },
            {
              "name": "LastRuntimeUpgrade",
              "modifier": "Optional",
              "type": {
                "Plain": "LastRuntimeUpgradeInfo"
              },
              "fallback": "0x00",
              "docs": [
                " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
              ]
            },
            {
              "name": "UpgradedToU32RefCount",
              "modifier": "Default",
              "type": {
                "Plain": "bool"
              },
              "fallback": "0x00",
              "docs": [
                " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
              ]
            },
            {
              "name": "UpgradedToTripleRefCount",
              "modifier": "Default",
              "type": {
                "Plain": "bool"
              },
              "fallback": "0x00",
              "docs": [
                " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                " (default) if not."
              ]
            },
            {
              "name": "ExecutionPhase",
              "modifier": "Optional",
              "type": {
                "Plain": "Phase"
              },
              "fallback": "0x00",
              "docs": [
                " The execution phase of the block."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "fill_block",
            "args": [
              {
                "name": "_ratio",
                "type": "Perbill"
              }
            ],
            "docs": [
              " A dispatch that will fill the block weight up to the given ratio."
            ]
          },
          {
            "name": "remark",
            "args": [
              {
                "name": "_remark",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Make some on-chain remark.",
              "",
              " # <weight>",
              " - `O(1)`",
              " # </weight>"
            ]
          },
          {
            "name": "set_heap_pages",
            "args": [
              {
                "name": "pages",
                "type": "u64"
              }
            ],
            "docs": [
              " Set the number of pages in the WebAssembly environment's heap.",
              "",
              " # <weight>",
              " - `O(1)`",
              " - 1 storage write.",
              " - Base Weight: 1.405 Âµs",
              " - 1 write to HEAP_PAGES",
              " # </weight>"
            ]
          },
          {
            "name": "set_code",
            "args": [
              {
                "name": "code",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Set the new runtime code.",
              "",
              " # <weight>",
              " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
              " - 1 storage write (codec `O(C)`).",
              " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
              " - 1 event.",
              " The weight of this function is dependent on the runtime, but generally this is very expensive.",
              " We will treat this as a full block.",
              " # </weight>"
            ]
          },
          {
            "name": "set_code_without_checks",
            "args": [
              {
                "name": "code",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Set the new runtime code without doing any checks of the given `code`.",
              "",
              " # <weight>",
              " - `O(C)` where `C` length of `code`",
              " - 1 storage write (codec `O(C)`).",
              " - 1 event.",
              " The weight of this function is dependent on the runtime. We will treat this as a full block.",
              " # </weight>"
            ]
          },
          {
            "name": "set_changes_trie_config",
            "args": [
              {
                "name": "changes_trie_config",
                "type": "Option<ChangesTrieConfiguration>"
              }
            ],
            "docs": [
              " Set the new changes trie configuration.",
              "",
              " # <weight>",
              " - `O(1)`",
              " - 1 storage write or delete (codec `O(1)`).",
              " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
              " - Base Weight: 7.218 Âµs",
              " - DB Weight:",
              "     - Writes: Changes Trie, System Digest",
              " # </weight>"
            ]
          },
          {
            "name": "set_storage",
            "args": [
              {
                "name": "items",
                "type": "Vec<KeyValue>"
              }
            ],
            "docs": [
              " Set some items of storage.",
              "",
              " # <weight>",
              " - `O(I)` where `I` length of `items`",
              " - `I` storage writes (`O(1)`).",
              " - Base Weight: 0.568 * i Âµs",
              " - Writes: Number of items",
              " # </weight>"
            ]
          },
          {
            "name": "kill_storage",
            "args": [
              {
                "name": "keys",
                "type": "Vec<Key>"
              }
            ],
            "docs": [
              " Kill some items from storage.",
              "",
              " # <weight>",
              " - `O(IK)` where `I` length of `keys` and `K` length of one key",
              " - `I` storage deletions.",
              " - Base Weight: .378 * i Âµs",
              " - Writes: Number of items",
              " # </weight>"
            ]
          },
          {
            "name": "kill_prefix",
            "args": [
              {
                "name": "prefix",
                "type": "Key"
              },
              {
                "name": "_subkeys",
                "type": "u32"
              }
            ],
            "docs": [
              " Kill all storage items with a key that starts with the given prefix.",
              "",
              " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
              " the prefix we are removing to accurately calculate the weight of this function.",
              "",
              " # <weight>",
              " - `O(P)` where `P` amount of keys with prefix `prefix`",
              " - `P` storage deletions.",
              " - Base Weight: 0.834 * P Âµs",
              " - Writes: Number of subkeys + 1",
              " # </weight>"
            ]
          },
          {
            "name": "remark_with_event",
            "args": [
              {
                "name": "remark",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Make some on-chain remark and emit event.",
              "",
              " # <weight>",
              " - `O(b)` where b is the length of the remark.",
              " - 1 event.",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "ExtrinsicSuccess",
            "args": [
              "DispatchInfo"
            ],
            "docs": [
              " An extrinsic completed successfully. \\[info\\]"
            ]
          },
          {
            "name": "ExtrinsicFailed",
            "args": [
              "DispatchError",
              "DispatchInfo"
            ],
            "docs": [
              " An extrinsic failed. \\[error, info\\]"
            ]
          },
          {
            "name": "CodeUpdated",
            "args": [],
            "docs": [
              " `:code` was updated."
            ]
          },
          {
            "name": "NewAccount",
            "args": [
              "AccountId"
            ],
            "docs": [
              " A new \\[account\\] was created."
            ]
          },
          {
            "name": "KilledAccount",
            "args": [
              "AccountId"
            ],
            "docs": [
              " An \\[account\\] was reaped."
            ]
          },
          {
            "name": "Remarked",
            "args": [
              "AccountId",
              "Hash"
            ],
            "docs": [
              " On on-chain remark happened. \\[origin, remark_hash\\]"
            ]
          }
        ],
        "constants": [
          {
            "name": "BlockWeights",
            "type": "BlockWeights",
            "value": "0x00f2052a010000000088526a74000000405973070000000001c0180fa44b0000000100e6bd4f57000000010000000000000000405973070000000001c0baa3be68000000010088526a740000000100a2941a1d0000004059730700000000000000",
            "docs": [
              " Block & extrinsics weights: base values and limits."
            ]
          },
          {
            "name": "BlockLength",
            "type": "BlockLength",
            "value": "0x00003c000000500000005000",
            "docs": [
              " The maximum length of a block (in bytes)."
            ]
          },
          {
            "name": "BlockHashCount",
            "type": "BlockNumber",
            "value": "0xfa000000",
            "docs": [
              " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
            ]
          },
          {
            "name": "DbWeight",
            "type": "RuntimeDbWeight",
            "value": "0x00000000000000000000000000000000",
            "docs": [
              " The weight of runtime database operations the runtime can invoke."
            ]
          },
          {
            "name": "Version",
            "type": "RuntimeVersion",
            "value": "0x486c6974656e7472792d70617261636861696e486c6974656e7472792d70617261636861696e01000000030000000100000020df6acb689907609b0300000037e397fc7c91f5e40100000040fe3ad401f8959a05000000d2bc9897eed08f1503000000f78b278be53f454c02000000ab3c0572291feb8b01000000dd718d5cc53262d401000000ea93e3f16f3d69620100000001000000",
            "docs": [
              " Get the chain's current version."
            ]
          },
          {
            "name": "SS58Prefix",
            "type": "u16",
            "value": "0x1f00",
            "docs": [
              " The designated SS85 prefix of this chain.",
              "",
              " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
              " that the runtime should know about the prefix in order to make use of it as",
              " an identifier of the chain."
            ]
          }
        ],
        "errors": [
          {
            "name": "InvalidSpecName",
            "docs": [
              " The name of specification does not match between the current runtime",
              " and the new runtime."
            ]
          },
          {
            "name": "SpecVersionNeedsToIncrease",
            "docs": [
              " The specification version is not allowed to decrease between the current runtime",
              " and the new runtime."
            ]
          },
          {
            "name": "FailedToExtractRuntimeVersion",
            "docs": [
              " Failed to extract the runtime version from the new runtime.",
              "",
              " Either calling `Core_version` or decoding `RuntimeVersion` failed."
            ]
          },
          {
            "name": "NonDefaultComposite",
            "docs": [
              " Suicide called when the account has non-default composite data."
            ]
          },
          {
            "name": "NonZeroRefCount",
            "docs": [
              " There is a non-zero reference count preventing the account from being purged."
            ]
          }
        ],
        "index": "0"
      },
      {
        "name": "Timestamp",
        "storage": {
          "prefix": "Timestamp",
          "items": [
            {
              "name": "Now",
              "modifier": "Default",
              "type": {
                "Plain": "Moment"
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " Current time for the current block."
              ]
            },
            {
              "name": "DidUpdate",
              "modifier": "Default",
              "type": {
                "Plain": "bool"
              },
              "fallback": "0x00",
              "docs": [
                " Did the timestamp get updated in this block?"
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "set",
            "args": [
              {
                "name": "now",
                "type": "Compact<Moment>"
              }
            ],
            "docs": [
              " Set the current time.",
              "",
              " This call should be invoked exactly once per block. It will panic at the finalization",
              " phase, if this call hasn't been invoked by that time.",
              "",
              " The timestamp should be greater than the previous one by the amount specified by",
              " `MinimumPeriod`.",
              "",
              " The dispatch origin for this call must be `Inherent`.",
              "",
              " # <weight>",
              " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
              " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
              " - 1 event handler `on_timestamp_set`. Must be `O(1)`.",
              " # </weight>"
            ]
          }
        ],
        "events": null,
        "constants": [
          {
            "name": "MinimumPeriod",
            "type": "Moment",
            "value": "0x7017000000000000",
            "docs": [
              " The minimum period between blocks. Beware that this is different to the *expected* period",
              " that the block production apparatus provides. Your chosen consensus system will generally",
              " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
              " period on default settings."
            ]
          }
        ],
        "errors": [],
        "index": "1"
      },
      {
        "name": "Sudo",
        "storage": {
          "prefix": "Sudo",
          "items": [
            {
              "name": "Key",
              "modifier": "Default",
              "type": {
                "Plain": "AccountId"
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The `AccountId` of the sudo key."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "sudo",
            "args": [
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Authenticates the sudo key and dispatches a function call with `Root` origin.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # <weight>",
              " - O(1).",
              " - Limited storage reads.",
              " - One DB write (event).",
              " - Weight of derivative `call` execution + 10,000.",
              " # </weight>"
            ]
          },
          {
            "name": "sudo_unchecked_weight",
            "args": [
              {
                "name": "call",
                "type": "Call"
              },
              {
                "name": "_weight",
                "type": "Weight"
              }
            ],
            "docs": [
              " Authenticates the sudo key and dispatches a function call with `Root` origin.",
              " This function does not check the weight of the call, and instead allows the",
              " Sudo user to specify the weight of the call.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # <weight>",
              " - O(1).",
              " - The weight of this call is defined by the caller.",
              " # </weight>"
            ]
          },
          {
            "name": "set_key",
            "args": [
              {
                "name": "new",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # <weight>",
              " - O(1).",
              " - Limited storage reads.",
              " - One DB change.",
              " # </weight>"
            ]
          },
          {
            "name": "sudo_as",
            "args": [
              {
                "name": "who",
                "type": "LookupSource"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
              " a given account.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # <weight>",
              " - O(1).",
              " - Limited storage reads.",
              " - One DB write (event).",
              " - Weight of derivative `call` execution + 10,000.",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "Sudid",
            "args": [
              "DispatchResult"
            ],
            "docs": [
              " A sudo just took place. \\[result\\]"
            ]
          },
          {
            "name": "KeyChanged",
            "args": [
              "AccountId"
            ],
            "docs": [
              " The \\[sudoer\\] just switched identity; the old key is supplied."
            ]
          },
          {
            "name": "SudoAsDone",
            "args": [
              "DispatchResult"
            ],
            "docs": [
              " A sudo just took place. \\[result\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "RequireSudo",
            "docs": [
              " Sender must be the Sudo account"
            ]
          }
        ],
        "index": "2"
      },
      {
        "name": "RandomnessCollectiveFlip",
        "storage": {
          "prefix": "RandomnessCollectiveFlip",
          "items": [
            {
              "name": "RandomMaterial",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<Hash>"
              },
              "fallback": "0x00",
              "docs": [
                " Series of block headers from the last 81 blocks that acts as random seed material. This",
                " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of",
                " the oldest hash."
              ]
            }
          ]
        },
        "calls": null,
        "events": null,
        "constants": [],
        "errors": [],
        "index": "3"
      },
      {
        "name": "Scheduler",
        "storage": {
          "prefix": "Scheduler",
          "items": [
            {
              "name": "Agenda",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "BlockNumber",
                  "value": "Vec<Option<Scheduled>>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Items to be executed, indexed by the block number that they should be executed on."
              ]
            },
            {
              "name": "Lookup",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "Bytes",
                  "value": "TaskAddress",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Lookup from identity to the block number and index of the task."
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "Plain": "Releases"
              },
              "fallback": "0x00",
              "docs": [
                " Storage version of the pallet.",
                "",
                " New networks start with last version."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "schedule",
            "args": [
              {
                "name": "when",
                "type": "BlockNumber"
              },
              {
                "name": "maybe_periodic",
                "type": "Option<Period>"
              },
              {
                "name": "priority",
                "type": "Priority"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Anonymously schedule a task.",
              "",
              " # <weight>",
              " - S = Number of already scheduled calls",
              " - Base Weight: 22.29 + .126 * S Âµs",
              " - DB Weight:",
              "     - Read: Agenda",
              "     - Write: Agenda",
              " - Will use base weight of 25 which should be good for up to 30 scheduled calls",
              " # </weight>"
            ]
          },
          {
            "name": "cancel",
            "args": [
              {
                "name": "when",
                "type": "BlockNumber"
              },
              {
                "name": "index",
                "type": "u32"
              }
            ],
            "docs": [
              " Cancel an anonymously scheduled task.",
              "",
              " # <weight>",
              " - S = Number of already scheduled calls",
              " - Base Weight: 22.15 + 2.869 * S Âµs",
              " - DB Weight:",
              "     - Read: Agenda",
              "     - Write: Agenda, Lookup",
              " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
              " # </weight>"
            ]
          },
          {
            "name": "schedule_named",
            "args": [
              {
                "name": "id",
                "type": "Bytes"
              },
              {
                "name": "when",
                "type": "BlockNumber"
              },
              {
                "name": "maybe_periodic",
                "type": "Option<Period>"
              },
              {
                "name": "priority",
                "type": "Priority"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Schedule a named task.",
              "",
              " # <weight>",
              " - S = Number of already scheduled calls",
              " - Base Weight: 29.6 + .159 * S Âµs",
              " - DB Weight:",
              "     - Read: Agenda, Lookup",
              "     - Write: Agenda, Lookup",
              " - Will use base weight of 35 which should be good for more than 30 scheduled calls",
              " # </weight>"
            ]
          },
          {
            "name": "cancel_named",
            "args": [
              {
                "name": "id",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Cancel a named scheduled task.",
              "",
              " # <weight>",
              " - S = Number of already scheduled calls",
              " - Base Weight: 24.91 + 2.907 * S Âµs",
              " - DB Weight:",
              "     - Read: Agenda, Lookup",
              "     - Write: Agenda, Lookup",
              " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
              " # </weight>"
            ]
          },
          {
            "name": "schedule_after",
            "args": [
              {
                "name": "after",
                "type": "BlockNumber"
              },
              {
                "name": "maybe_periodic",
                "type": "Option<Period>"
              },
              {
                "name": "priority",
                "type": "Priority"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Anonymously schedule a task after a delay.",
              "",
              " # <weight>",
              " Same as [`schedule`].",
              " # </weight>"
            ]
          },
          {
            "name": "schedule_named_after",
            "args": [
              {
                "name": "id",
                "type": "Bytes"
              },
              {
                "name": "after",
                "type": "BlockNumber"
              },
              {
                "name": "maybe_periodic",
                "type": "Option<Period>"
              },
              {
                "name": "priority",
                "type": "Priority"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Schedule a named task after a delay.",
              "",
              " # <weight>",
              " Same as [`schedule_named`].",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "Scheduled",
            "args": [
              "BlockNumber",
              "u32"
            ],
            "docs": [
              " Scheduled some task. \\[when, index\\]"
            ]
          },
          {
            "name": "Canceled",
            "args": [
              "BlockNumber",
              "u32"
            ],
            "docs": [
              " Canceled some task. \\[when, index\\]"
            ]
          },
          {
            "name": "Dispatched",
            "args": [
              "TaskAddress",
              "Option<Bytes>",
              "DispatchResult"
            ],
            "docs": [
              " Dispatched some task. \\[task, id, result\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "FailedToSchedule",
            "docs": [
              " Failed to schedule a call"
            ]
          },
          {
            "name": "NotFound",
            "docs": [
              " Cannot find the scheduled call."
            ]
          },
          {
            "name": "TargetBlockNumberInPast",
            "docs": [
              " Given target block number is in the past."
            ]
          },
          {
            "name": "RescheduleNoChange",
            "docs": [
              " Reschedule failed because it does not change scheduled time."
            ]
          }
        ],
        "index": "4"
      },
      {
        "name": "TransactionPayment",
        "storage": {
          "prefix": "TransactionPayment",
          "items": [
            {
              "name": "NextFeeMultiplier",
              "modifier": "Default",
              "type": {
                "Plain": "Multiplier"
              },
              "fallback": "0x000064a7b3b6e00d0000000000000000",
              "docs": []
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "Plain": "Releases"
              },
              "fallback": "0x00",
              "docs": []
            }
          ]
        },
        "calls": null,
        "events": null,
        "constants": [
          {
            "name": "TransactionByteFee",
            "type": "BalanceOf",
            "value": "0x40420f00000000000000000000000000",
            "docs": [
              " The fee to be paid for making a transaction; the per-byte portion."
            ]
          },
          {
            "name": "WeightToFee",
            "type": "Vec<WeightToFeeCoefficient>",
            "value": "0x0401000000000000000000000000000000000000000001",
            "docs": [
              " The polynomial that is applied in order to derive fee from weight."
            ]
          }
        ],
        "errors": [],
        "index": "5"
      },
      {
        "name": "Treasury",
        "storage": {
          "prefix": "Treasury",
          "items": [
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "Plain": "ProposalIndex"
              },
              "fallback": "0x00000000",
              "docs": [
                " Number of proposals that have been made."
              ]
            },
            {
              "name": "Proposals",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "ProposalIndex",
                  "value": "TreasuryProposal",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Proposals that have been made."
              ]
            },
            {
              "name": "Approvals",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<ProposalIndex>"
              },
              "fallback": "0x00",
              "docs": [
                " Proposal indices that have been approved but not yet awarded."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "propose_spend",
            "args": [
              {
                "name": "value",
                "type": "Compact<BalanceOf>"
              },
              {
                "name": "beneficiary",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Put forward a suggestion for spending. A deposit proportional to the value",
              " is reserved and slashed if the proposal is rejected. It is returned once the",
              " proposal is awarded.",
              "",
              " # <weight>",
              " - Complexity: O(1)",
              " - DbReads: `ProposalCount`, `origin account`",
              " - DbWrites: `ProposalCount`, `Proposals`, `origin account`",
              " # </weight>"
            ]
          },
          {
            "name": "reject_proposal",
            "args": [
              {
                "name": "proposal_id",
                "type": "Compact<ProposalIndex>"
              }
            ],
            "docs": [
              " Reject a proposed spend. The original deposit will be slashed.",
              "",
              " May only be called from `T::RejectOrigin`.",
              "",
              " # <weight>",
              " - Complexity: O(1)",
              " - DbReads: `Proposals`, `rejected proposer account`",
              " - DbWrites: `Proposals`, `rejected proposer account`",
              " # </weight>"
            ]
          },
          {
            "name": "approve_proposal",
            "args": [
              {
                "name": "proposal_id",
                "type": "Compact<ProposalIndex>"
              }
            ],
            "docs": [
              " Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
              " and the original deposit will be returned.",
              "",
              " May only be called from `T::ApproveOrigin`.",
              "",
              " # <weight>",
              " - Complexity: O(1).",
              " - DbReads: `Proposals`, `Approvals`",
              " - DbWrite: `Approvals`",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "Proposed",
            "args": [
              "ProposalIndex"
            ],
            "docs": [
              " New proposal. \\[proposal_index\\]"
            ]
          },
          {
            "name": "Spending",
            "args": [
              "Balance"
            ],
            "docs": [
              " We have ended a spend period and will now allocate funds. \\[budget_remaining\\]"
            ]
          },
          {
            "name": "Awarded",
            "args": [
              "ProposalIndex",
              "Balance",
              "AccountId"
            ],
            "docs": [
              " Some funds have been allocated. \\[proposal_index, award, beneficiary\\]"
            ]
          },
          {
            "name": "Rejected",
            "args": [
              "ProposalIndex",
              "Balance"
            ],
            "docs": [
              " A proposal was rejected; funds were slashed. \\[proposal_index, slashed\\]"
            ]
          },
          {
            "name": "Burnt",
            "args": [
              "Balance"
            ],
            "docs": [
              " Some of our funds have been burnt. \\[burn\\]"
            ]
          },
          {
            "name": "Rollover",
            "args": [
              "Balance"
            ],
            "docs": [
              " Spending has finished; this is the amount that rolls over until next spend.",
              " \\[budget_remaining\\]"
            ]
          },
          {
            "name": "Deposit",
            "args": [
              "Balance"
            ],
            "docs": [
              " Some funds have been deposited. \\[deposit\\]"
            ]
          }
        ],
        "constants": [
          {
            "name": "ProposalBond",
            "type": "Permill",
            "value": "0x50c30000",
            "docs": [
              " Fraction of a proposal's value that should be bonded in order to place the proposal.",
              " An accepted proposal gets these back. A rejected proposal does not."
            ]
          },
          {
            "name": "ProposalBondMinimum",
            "type": "BalanceOf",
            "value": "0x00407a10f35a00000000000000000000",
            "docs": [
              " Minimum amount of funds that should be placed in a deposit for making a proposal."
            ]
          },
          {
            "name": "SpendPeriod",
            "type": "BlockNumber",
            "value": "0x201c0000",
            "docs": [
              " Period between successive spends."
            ]
          },
          {
            "name": "Burn",
            "type": "Permill",
            "value": "0x20a10700",
            "docs": [
              " Percentage of spare funds (if any) that are burnt per spend period."
            ]
          },
          {
            "name": "PalletId",
            "type": "PalletId",
            "value": "py/trsry",
            "docs": [
              " The treasury's module id, used for deriving its sovereign account ID."
            ]
          }
        ],
        "errors": [
          {
            "name": "InsufficientProposersBalance",
            "docs": [
              " Proposer's balance is too low."
            ]
          },
          {
            "name": "InvalidIndex",
            "docs": [
              " No proposal or bounty at that index."
            ]
          },
          {
            "name": "TooManyApprovals",
            "docs": [
              " Too many approvals in the queue."
            ]
          }
        ],
        "index": "6"
      },
      {
        "name": "Democracy",
        "storage": {
          "prefix": "Democracy",
          "items": [
            {
              "name": "PublicPropCount",
              "modifier": "Default",
              "type": {
                "Plain": "PropIndex"
              },
              "fallback": "0x00000000",
              "docs": [
                " The number of (public) proposals that have been made so far."
              ]
            },
            {
              "name": "PublicProps",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<(PropIndex,Hash,AccountId)>"
              },
              "fallback": "0x00",
              "docs": [
                " The public proposals. Unsorted. The second item is the proposal's hash."
              ]
            },
            {
              "name": "DepositOf",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "PropIndex",
                  "value": "(Vec<AccountId>,BalanceOf)",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Those who have locked a deposit.",
                "",
                " TWOX-NOTE: Safe, as increasing integer keys are safe."
              ]
            },
            {
              "name": "Preimages",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "PreimageStatus",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Map of hashes to the proposal preimage, along with who registered it and their deposit.",
                " The block number is the block at which it was deposited."
              ]
            },
            {
              "name": "ReferendumCount",
              "modifier": "Default",
              "type": {
                "Plain": "ReferendumIndex"
              },
              "fallback": "0x00000000",
              "docs": [
                " The next free referendum index, aka the number of referenda started so far."
              ]
            },
            {
              "name": "LowestUnbaked",
              "modifier": "Default",
              "type": {
                "Plain": "ReferendumIndex"
              },
              "fallback": "0x00000000",
              "docs": [
                " The lowest referendum index representing an unbaked referendum. Equal to",
                " `ReferendumCount` if there isn't a unbaked referendum."
              ]
            },
            {
              "name": "ReferendumInfoOf",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "ReferendumIndex",
                  "value": "ReferendumInfo",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Information concerning any given referendum.",
                "",
                " TWOX-NOTE: SAFE as indexes are not under an attackerâs control."
              ]
            },
            {
              "name": "VotingOf",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "Voting",
                  "linked": false
                }
              },
              "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " All votes for a particular voter. We store the balance for the number of votes that we",
                " have recorded. The second item is the total amount of delegations, that will be added.",
                "",
                " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."
              ]
            },
            {
              "name": "Locks",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "BlockNumber",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Accounts for which there are locks in action which may be removed at some point in the",
                " future. The value is the block number at which the lock expires and may be removed.",
                "",
                " TWOX-NOTE: OK â `AccountId` is a secure hash."
              ]
            },
            {
              "name": "LastTabledWasExternal",
              "modifier": "Default",
              "type": {
                "Plain": "bool"
              },
              "fallback": "0x00",
              "docs": [
                " True if the last referendum tabled was submitted externally. False if it was a public",
                " proposal."
              ]
            },
            {
              "name": "NextExternal",
              "modifier": "Optional",
              "type": {
                "Plain": "(Hash,VoteThreshold)"
              },
              "fallback": "0x00",
              "docs": [
                " The referendum to be tabled whenever it would be valid to table an external proposal.",
                " This happens when a referendum needs to be tabled and one of two conditions are met:",
                " - `LastTabledWasExternal` is `false`; or",
                " - `PublicProps` is empty."
              ]
            },
            {
              "name": "Blacklist",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "(BlockNumber,Vec<AccountId>)",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " A record of who vetoed what. Maps proposal hash to a possible existent block number",
                " (until when it may not be resubmitted) and who vetoed it."
              ]
            },
            {
              "name": "Cancellations",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "bool",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Record of all proposals that have been subject to emergency cancellation."
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Optional",
              "type": {
                "Plain": "Releases"
              },
              "fallback": "0x00",
              "docs": [
                " Storage version of the pallet.",
                "",
                " New networks start with last version."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "propose",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "value",
                "type": "Compact<BalanceOf>"
              }
            ],
            "docs": [
              " Propose a sensitive action to be taken.",
              "",
              " The dispatch origin of this call must be _Signed_ and the sender must",
              " have funds to cover the deposit.",
              "",
              " - `proposal_hash`: The hash of the proposal preimage.",
              " - `value`: The amount of deposit (must be at least `MinimumDeposit`).",
              "",
              " Emits `Proposed`.",
              "",
              " Weight: `O(p)`"
            ]
          },
          {
            "name": "second",
            "args": [
              {
                "name": "proposal",
                "type": "Compact<PropIndex>"
              },
              {
                "name": "seconds_upper_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Signals agreement with a particular proposal.",
              "",
              " The dispatch origin of this call must be _Signed_ and the sender",
              " must have funds to cover the deposit, equal to the original deposit.",
              "",
              " - `proposal`: The index of the proposal to second.",
              " - `seconds_upper_bound`: an upper bound on the current number of seconds on this",
              "   proposal. Extrinsic is weighted according to this value with no refund.",
              "",
              " Weight: `O(S)` where S is the number of seconds a proposal already has."
            ]
          },
          {
            "name": "vote",
            "args": [
              {
                "name": "ref_index",
                "type": "Compact<ReferendumIndex>"
              },
              {
                "name": "vote",
                "type": "AccountVote"
              }
            ],
            "docs": [
              " Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
              " otherwise it is a vote to keep the status quo.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `ref_index`: The index of the referendum to vote for.",
              " - `vote`: The vote configuration.",
              "",
              " Weight: `O(R)` where R is the number of referendums the voter has voted on."
            ]
          },
          {
            "name": "emergency_cancel",
            "args": [
              {
                "name": "ref_index",
                "type": "ReferendumIndex"
              }
            ],
            "docs": [
              " Schedule an emergency cancellation of a referendum. Cannot happen twice to the same",
              " referendum.",
              "",
              " The dispatch origin of this call must be `CancellationOrigin`.",
              "",
              " -`ref_index`: The index of the referendum to cancel.",
              "",
              " Weight: `O(1)`."
            ]
          },
          {
            "name": "external_propose",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              }
            ],
            "docs": [
              " Schedule a referendum to be tabled once it is legal to schedule an external",
              " referendum.",
              "",
              " The dispatch origin of this call must be `ExternalOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal.",
              "",
              " Weight: `O(V)` with V number of vetoers in the blacklist of proposal.",
              "   Decoding vec of length V. Charged as maximum"
            ]
          },
          {
            "name": "external_propose_majority",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              }
            ],
            "docs": [
              " Schedule a majority-carries referendum to be tabled next once it is legal to schedule",
              " an external referendum.",
              "",
              " The dispatch of this call must be `ExternalMajorityOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal.",
              "",
              " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
              " pre-scheduled `external_propose` call.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "external_propose_default",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              }
            ],
            "docs": [
              " Schedule a negative-turnout-bias referendum to be tabled next once it is legal to",
              " schedule an external referendum.",
              "",
              " The dispatch of this call must be `ExternalDefaultOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal.",
              "",
              " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
              " pre-scheduled `external_propose` call.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "fast_track",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "voting_period",
                "type": "BlockNumber"
              },
              {
                "name": "delay",
                "type": "BlockNumber"
              }
            ],
            "docs": [
              " Schedule the currently externally-proposed majority-carries referendum to be tabled",
              " immediately. If there is no externally-proposed referendum currently, or if there is one",
              " but it is not a majority-carries referendum then it fails.",
              "",
              " The dispatch of this call must be `FastTrackOrigin`.",
              "",
              " - `proposal_hash`: The hash of the current external proposal.",
              " - `voting_period`: The period that is allowed for voting on this proposal. Increased to",
              "   `FastTrackVotingPeriod` if too low.",
              " - `delay`: The number of block after voting has ended in approval and this should be",
              "   enacted. This doesn't have a minimum amount.",
              "",
              " Emits `Started`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "veto_external",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              }
            ],
            "docs": [
              " Veto and blacklist the external proposal hash.",
              "",
              " The dispatch origin of this call must be `VetoOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.",
              "",
              " Emits `Vetoed`.",
              "",
              " Weight: `O(V + log(V))` where V is number of `existing vetoers`"
            ]
          },
          {
            "name": "cancel_referendum",
            "args": [
              {
                "name": "ref_index",
                "type": "Compact<ReferendumIndex>"
              }
            ],
            "docs": [
              " Remove a referendum.",
              "",
              " The dispatch origin of this call must be _Root_.",
              "",
              " - `ref_index`: The index of the referendum to cancel.",
              "",
              " # Weight: `O(1)`."
            ]
          },
          {
            "name": "cancel_queued",
            "args": [
              {
                "name": "which",
                "type": "ReferendumIndex"
              }
            ],
            "docs": [
              " Cancel a proposal queued for enactment.",
              "",
              " The dispatch origin of this call must be _Root_.",
              "",
              " - `which`: The index of the referendum to cancel.",
              "",
              " Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."
            ]
          },
          {
            "name": "delegate",
            "args": [
              {
                "name": "to",
                "type": "AccountId"
              },
              {
                "name": "conviction",
                "type": "Conviction"
              },
              {
                "name": "balance",
                "type": "BalanceOf"
              }
            ],
            "docs": [
              " Delegate the voting power (with some given conviction) of the sending account.",
              "",
              " The balance delegated is locked for as long as it's delegated, and thereafter for the",
              " time appropriate for the conviction's lock period.",
              "",
              " The dispatch origin of this call must be _Signed_, and the signing account must either:",
              "   - be delegating already; or",
              "   - have no voting activity (if there is, then it will need to be removed/consolidated",
              "     through `reap_vote` or `unvote`).",
              "",
              " - `to`: The account whose voting the `target` account's voting power will follow.",
              " - `conviction`: The conviction that will be attached to the delegated votes. When the",
              "   account is undelegated, the funds will be locked for the corresponding period.",
              " - `balance`: The amount of the account's balance to be used in delegating. This must",
              "   not be more than the account's current balance.",
              "",
              " Emits `Delegated`.",
              "",
              " Weight: `O(R)` where R is the number of referendums the voter delegating to has",
              "   voted on. Weight is charged as if maximum votes."
            ]
          },
          {
            "name": "undelegate",
            "args": [],
            "docs": [
              " Undelegate the voting power of the sending account.",
              "",
              " Tokens may be unlocked following once an amount of time consistent with the lock period",
              " of the conviction with which the delegation was issued.",
              "",
              " The dispatch origin of this call must be _Signed_ and the signing account must be",
              " currently delegating.",
              "",
              " Emits `Undelegated`.",
              "",
              " Weight: `O(R)` where R is the number of referendums the voter delegating to has",
              "   voted on. Weight is charged as if maximum votes."
            ]
          },
          {
            "name": "clear_public_proposals",
            "args": [],
            "docs": [
              " Clears all public proposals.",
              "",
              " The dispatch origin of this call must be _Root_.",
              "",
              " Weight: `O(1)`."
            ]
          },
          {
            "name": "note_preimage",
            "args": [
              {
                "name": "encoded_proposal",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Register the preimage for an upcoming proposal. This doesn't require the proposal to be",
              " in the dispatch queue but does require a deposit, returned once enacted.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `encoded_proposal`: The preimage of a proposal.",
              "",
              " Emits `PreimageNoted`.",
              "",
              " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
            ]
          },
          {
            "name": "note_preimage_operational",
            "args": [
              {
                "name": "encoded_proposal",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Same as `note_preimage` but origin is `OperationalPreimageOrigin`."
            ]
          },
          {
            "name": "note_imminent_preimage",
            "args": [
              {
                "name": "encoded_proposal",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Register the preimage for an upcoming proposal. This requires the proposal to be",
              " in the dispatch queue. No deposit is needed. When this call is successful, i.e.",
              " the preimage has not been uploaded before and matches some imminent proposal,",
              " no fee is paid.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `encoded_proposal`: The preimage of a proposal.",
              "",
              " Emits `PreimageNoted`.",
              "",
              " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
            ]
          },
          {
            "name": "note_imminent_preimage_operational",
            "args": [
              {
                "name": "encoded_proposal",
                "type": "Bytes"
              }
            ],
            "docs": [
              " Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."
            ]
          },
          {
            "name": "reap_preimage",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "proposal_len_upper_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Remove an expired proposal preimage and collect the deposit.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `proposal_hash`: The preimage hash of a proposal.",
              " - `proposal_length_upper_bound`: an upper bound on length of the proposal.",
              "   Extrinsic is weighted according to this value with no refund.",
              "",
              " This will only work after `VotingPeriod` blocks from the time that the preimage was",
              " noted, if it's the same account doing it. If it's a different account, then it'll only",
              " work an additional `EnactmentPeriod` later.",
              "",
              " Emits `PreimageReaped`.",
              "",
              " Weight: `O(D)` where D is length of proposal."
            ]
          },
          {
            "name": "unlock",
            "args": [
              {
                "name": "target",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Unlock tokens that have an expired lock.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `target`: The account to remove the lock on.",
              "",
              " Weight: `O(R)` with R number of vote of target."
            ]
          },
          {
            "name": "remove_vote",
            "args": [
              {
                "name": "index",
                "type": "ReferendumIndex"
              }
            ],
            "docs": [
              " Remove a vote for a referendum.",
              "",
              " If:",
              " - the referendum was cancelled, or",
              " - the referendum is ongoing, or",
              " - the referendum has ended such that",
              "   - the vote of the account was in opposition to the result; or",
              "   - there was no conviction to the account's vote; or",
              "   - the account made a split vote",
              " ...then the vote is removed cleanly and a following call to `unlock` may result in more",
              " funds being available.",
              "",
              " If, however, the referendum has ended and:",
              " - it finished corresponding to the vote of the account, and",
              " - the account made a standard vote with conviction, and",
              " - the lock period of the conviction is not over",
              " ...then the lock will be aggregated into the overall account's lock, which may involve",
              " *overlocking* (where the two locks are combined into a single lock that is the maximum",
              " of both the amount locked and the time is it locked for).",
              "",
              " The dispatch origin of this call must be _Signed_, and the signer must have a vote",
              " registered for referendum `index`.",
              "",
              " - `index`: The index of referendum of the vote to be removed.",
              "",
              " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
              "   Weight is calculated for the maximum number of vote."
            ]
          },
          {
            "name": "remove_other_vote",
            "args": [
              {
                "name": "target",
                "type": "AccountId"
              },
              {
                "name": "index",
                "type": "ReferendumIndex"
              }
            ],
            "docs": [
              " Remove a vote for a referendum.",
              "",
              " If the `target` is equal to the signer, then this function is exactly equivalent to",
              " `remove_vote`. If not equal to the signer, then the vote must have expired,",
              " either because the referendum was cancelled, because the voter lost the referendum or",
              " because the conviction period is over.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `target`: The account of the vote to be removed; this account must have voted for",
              "   referendum `index`.",
              " - `index`: The index of referendum of the vote to be removed.",
              "",
              " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
              "   Weight is calculated for the maximum number of vote."
            ]
          },
          {
            "name": "enact_proposal",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "index",
                "type": "ReferendumIndex"
              }
            ],
            "docs": [
              " Enact a proposal from a referendum. For now we just make the weight be the maximum."
            ]
          },
          {
            "name": "blacklist",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "maybe_ref_index",
                "type": "Option<ReferendumIndex>"
              }
            ],
            "docs": [
              " Permanently place a proposal into the blacklist. This prevents it from ever being",
              " proposed again.",
              "",
              " If called on a queued public or external proposal, then this will result in it being",
              " removed. If the `ref_index` supplied is an active referendum with the proposal hash,",
              " then it will be cancelled.",
              "",
              " The dispatch origin of this call must be `BlacklistOrigin`.",
              "",
              " - `proposal_hash`: The proposal hash to blacklist permanently.",
              " - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be",
              " cancelled.",
              "",
              " Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a",
              "   reasonable value)."
            ]
          },
          {
            "name": "cancel_proposal",
            "args": [
              {
                "name": "prop_index",
                "type": "Compact<PropIndex>"
              }
            ],
            "docs": [
              " Remove a proposal.",
              "",
              " The dispatch origin of this call must be `CancelProposalOrigin`.",
              "",
              " - `prop_index`: The index of the proposal to cancel.",
              "",
              " Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"
            ]
          }
        ],
        "events": [
          {
            "name": "Proposed",
            "args": [
              "PropIndex",
              "Balance"
            ],
            "docs": [
              " A motion has been proposed by a public account. \\[proposal_index, deposit\\]"
            ]
          },
          {
            "name": "Tabled",
            "args": [
              "PropIndex",
              "Balance",
              "Vec<AccountId>"
            ],
            "docs": [
              " A public proposal has been tabled for referendum vote. \\[proposal_index, deposit, depositors\\]"
            ]
          },
          {
            "name": "ExternalTabled",
            "args": [],
            "docs": [
              " An external proposal has been tabled."
            ]
          },
          {
            "name": "Started",
            "args": [
              "ReferendumIndex",
              "VoteThreshold"
            ],
            "docs": [
              " A referendum has begun. \\[ref_index, threshold\\]"
            ]
          },
          {
            "name": "Passed",
            "args": [
              "ReferendumIndex"
            ],
            "docs": [
              " A proposal has been approved by referendum. \\[ref_index\\]"
            ]
          },
          {
            "name": "NotPassed",
            "args": [
              "ReferendumIndex"
            ],
            "docs": [
              " A proposal has been rejected by referendum. \\[ref_index\\]"
            ]
          },
          {
            "name": "Cancelled",
            "args": [
              "ReferendumIndex"
            ],
            "docs": [
              " A referendum has been cancelled. \\[ref_index\\]"
            ]
          },
          {
            "name": "Executed",
            "args": [
              "ReferendumIndex",
              "bool"
            ],
            "docs": [
              " A proposal has been enacted. \\[ref_index, is_ok\\]"
            ]
          },
          {
            "name": "Delegated",
            "args": [
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " An account has delegated their vote to another account. \\[who, target\\]"
            ]
          },
          {
            "name": "Undelegated",
            "args": [
              "AccountId"
            ],
            "docs": [
              " An \\[account\\] has cancelled a previous delegation operation."
            ]
          },
          {
            "name": "Vetoed",
            "args": [
              "AccountId",
              "Hash",
              "BlockNumber"
            ],
            "docs": [
              " An external proposal has been vetoed. \\[who, proposal_hash, until\\]"
            ]
          },
          {
            "name": "PreimageNoted",
            "args": [
              "Hash",
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A proposal's preimage was noted, and the deposit taken. \\[proposal_hash, who, deposit\\]"
            ]
          },
          {
            "name": "PreimageUsed",
            "args": [
              "Hash",
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A proposal preimage was removed and used (the deposit was returned).",
              " \\[proposal_hash, provider, deposit\\]"
            ]
          },
          {
            "name": "PreimageInvalid",
            "args": [
              "Hash",
              "ReferendumIndex"
            ],
            "docs": [
              " A proposal could not be executed because its preimage was invalid.",
              " \\[proposal_hash, ref_index\\]"
            ]
          },
          {
            "name": "PreimageMissing",
            "args": [
              "Hash",
              "ReferendumIndex"
            ],
            "docs": [
              " A proposal could not be executed because its preimage was missing.",
              " \\[proposal_hash, ref_index\\]"
            ]
          },
          {
            "name": "PreimageReaped",
            "args": [
              "Hash",
              "AccountId",
              "Balance",
              "AccountId"
            ],
            "docs": [
              " A registered preimage was removed and the deposit collected by the reaper.",
              " \\[proposal_hash, provider, deposit, reaper\\]"
            ]
          },
          {
            "name": "Unlocked",
            "args": [
              "AccountId"
            ],
            "docs": [
              " An \\[account\\] has been unlocked successfully."
            ]
          },
          {
            "name": "Blacklisted",
            "args": [
              "Hash"
            ],
            "docs": [
              " A proposal \\[hash\\] has been blacklisted permanently."
            ]
          }
        ],
        "constants": [
          {
            "name": "EnactmentPeriod",
            "type": "BlockNumber",
            "value": "0xc04b0300",
            "docs": [
              " The minimum period of locking and the period between a proposal being approved and enacted.",
              "",
              " It should generally be a little more than the unstake period to ensure that",
              " voting stakers have an opportunity to remove themselves from the system in the case where",
              " they are on the losing side of a vote."
            ]
          },
          {
            "name": "LaunchPeriod",
            "type": "BlockNumber",
            "value": "0x80130300",
            "docs": [
              " How often (in blocks) new public referenda are launched."
            ]
          },
          {
            "name": "VotingPeriod",
            "type": "BlockNumber",
            "value": "0x80130300",
            "docs": [
              " How often (in blocks) to check for new votes."
            ]
          },
          {
            "name": "MinimumDeposit",
            "type": "BalanceOf",
            "value": "0x0000c16ff28623000000000000000000",
            "docs": [
              " The minimum amount to be used as a deposit for a public referendum proposal."
            ]
          },
          {
            "name": "FastTrackVotingPeriod",
            "type": "BlockNumber",
            "value": "0x60540000",
            "docs": [
              " Minimum voting period allowed for a fast-track referendum."
            ]
          },
          {
            "name": "CooloffPeriod",
            "type": "BlockNumber",
            "value": "0x80130300",
            "docs": [
              " Period in blocks where an external proposal may not be re-submitted after being vetoed."
            ]
          },
          {
            "name": "PreimageByteDeposit",
            "type": "BalanceOf",
            "value": "0x0010a5d4e80000000000000000000000",
            "docs": [
              " The amount of balance that must be deposited per byte of preimage stored."
            ]
          },
          {
            "name": "MaxVotes",
            "type": "u32",
            "value": "0x64000000",
            "docs": [
              " The maximum number of votes for an account.",
              "",
              " Also used to compute weight, an overly big value can",
              " lead to extrinsic with very big weight: see `delegate` for instance."
            ]
          }
        ],
        "errors": [
          {
            "name": "ValueLow",
            "docs": [
              " Value too low"
            ]
          },
          {
            "name": "ProposalMissing",
            "docs": [
              " Proposal does not exist"
            ]
          },
          {
            "name": "BadIndex",
            "docs": [
              " Unknown index"
            ]
          },
          {
            "name": "AlreadyCanceled",
            "docs": [
              " Cannot cancel the same proposal twice"
            ]
          },
          {
            "name": "DuplicateProposal",
            "docs": [
              " Proposal already made"
            ]
          },
          {
            "name": "ProposalBlacklisted",
            "docs": [
              " Proposal still blacklisted"
            ]
          },
          {
            "name": "NotSimpleMajority",
            "docs": [
              " Next external proposal not simple majority"
            ]
          },
          {
            "name": "InvalidHash",
            "docs": [
              " Invalid hash"
            ]
          },
          {
            "name": "NoProposal",
            "docs": [
              " No external proposal"
            ]
          },
          {
            "name": "AlreadyVetoed",
            "docs": [
              " Identity may not veto a proposal twice"
            ]
          },
          {
            "name": "NotDelegated",
            "docs": [
              " Not delegated"
            ]
          },
          {
            "name": "DuplicatePreimage",
            "docs": [
              " Preimage already noted"
            ]
          },
          {
            "name": "NotImminent",
            "docs": [
              " Not imminent"
            ]
          },
          {
            "name": "TooEarly",
            "docs": [
              " Too early"
            ]
          },
          {
            "name": "Imminent",
            "docs": [
              " Imminent"
            ]
          },
          {
            "name": "PreimageMissing",
            "docs": [
              " Preimage not found"
            ]
          },
          {
            "name": "ReferendumInvalid",
            "docs": [
              " Vote given for invalid referendum"
            ]
          },
          {
            "name": "PreimageInvalid",
            "docs": [
              " Invalid preimage"
            ]
          },
          {
            "name": "NoneWaiting",
            "docs": [
              " No proposals waiting"
            ]
          },
          {
            "name": "NotLocked",
            "docs": [
              " The target account does not have a lock."
            ]
          },
          {
            "name": "NotExpired",
            "docs": [
              " The lock on the account to be unlocked has not yet expired."
            ]
          },
          {
            "name": "NotVoter",
            "docs": [
              " The given account did not vote on the referendum."
            ]
          },
          {
            "name": "NoPermission",
            "docs": [
              " The actor has no permission to conduct the action."
            ]
          },
          {
            "name": "AlreadyDelegating",
            "docs": [
              " The account is already delegating."
            ]
          },
          {
            "name": "InsufficientFunds",
            "docs": [
              " Too high a balance was provided that the account cannot afford."
            ]
          },
          {
            "name": "NotDelegating",
            "docs": [
              " The account is not currently delegating."
            ]
          },
          {
            "name": "VotesExist",
            "docs": [
              " The account currently has votes attached to it and the operation cannot succeed until",
              " these are removed, either through `unvote` or `reap_vote`."
            ]
          },
          {
            "name": "InstantNotAllowed",
            "docs": [
              " The instant referendum origin is currently disallowed."
            ]
          },
          {
            "name": "Nonsense",
            "docs": [
              " Delegation to oneself makes no sense."
            ]
          },
          {
            "name": "WrongUpperBound",
            "docs": [
              " Invalid upper bound."
            ]
          },
          {
            "name": "MaxVotesReached",
            "docs": [
              " Maximum number of votes reached."
            ]
          },
          {
            "name": "InvalidWitness",
            "docs": [
              " The provided witness data is wrong."
            ]
          },
          {
            "name": "TooManyProposals",
            "docs": [
              " Maximum number of proposals reached."
            ]
          }
        ],
        "index": "7"
      },
      {
        "name": "Council",
        "storage": {
          "prefix": "Instance1Collective",
          "items": [
            {
              "name": "Proposals",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<Hash>"
              },
              "fallback": "0x00",
              "docs": [
                " The hashes of the active proposals."
              ]
            },
            {
              "name": "ProposalOf",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "Proposal",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Actual proposal for a given hash, if it's current."
              ]
            },
            {
              "name": "Voting",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "Votes",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Votes on a given proposal, if it is ongoing."
              ]
            },
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00000000",
              "docs": [
                " Proposals so far."
              ]
            },
            {
              "name": "Members",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "docs": [
                " The current members of the collective. This is stored sorted (just by value)."
              ]
            },
            {
              "name": "Prime",
              "modifier": "Optional",
              "type": {
                "Plain": "AccountId"
              },
              "fallback": "0x00",
              "docs": [
                " The prime member that helps determine the default vote behavior in case of absentations."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "set_members",
            "args": [
              {
                "name": "new_members",
                "type": "Vec<AccountId>"
              },
              {
                "name": "prime",
                "type": "Option<AccountId>"
              },
              {
                "name": "old_count",
                "type": "MemberCount"
              }
            ],
            "docs": [
              " Set the collective's membership.",
              "",
              " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
              " - `prime`: The prime member whose vote sets the default.",
              " - `old_count`: The upper bound for the previous number of members in storage.",
              "                Used for weight estimation.",
              "",
              " Requires root origin.",
              "",
              " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
              "       the weight estimations rely on it to estimate dispatchable weight.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(MP + N)` where:",
              "   - `M` old-members-count (code- and governance-bounded)",
              "   - `N` new-members-count (code- and governance-bounded)",
              "   - `P` proposals-count (code-bounded)",
              " - DB:",
              "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
              "   - 1 storage read (codec `O(P)`) for reading the proposals",
              "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
              "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
              " # </weight>"
            ]
          },
          {
            "name": "execute",
            "args": [
              {
                "name": "proposal",
                "type": "Proposal"
              },
              {
                "name": "length_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Dispatch a proposal from a member using the `Member` origin.",
              "",
              " Origin must be a member of the collective.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
              " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
              " - 1 event",
              " # </weight>"
            ]
          },
          {
            "name": "propose",
            "args": [
              {
                "name": "threshold",
                "type": "Compact<MemberCount>"
              },
              {
                "name": "proposal",
                "type": "Proposal"
              },
              {
                "name": "length_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Add a new proposal to either be voted on or executed directly.",
              "",
              " Requires the sender to be member.",
              "",
              " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)",
              " or put up for voting.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(B + M + P1)` or `O(B + M + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - branching is influenced by `threshold` where:",
              "     - `P1` is proposal execution complexity (`threshold < 2`)",
              "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)",
              " - DB:",
              "   - 1 storage read `is_member` (codec `O(M)`)",
              "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
              "   - DB accesses influenced by `threshold`:",
              "     - EITHER storage accesses done by `proposal` (`threshold < 2`)",
              "     - OR proposal insertion (`threshold <= 2`)",
              "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
              "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
              "       - 1 storage write `ProposalOf` (codec `O(B)`)",
              "       - 1 storage write `Voting` (codec `O(M)`)",
              "   - 1 event",
              " # </weight>"
            ]
          },
          {
            "name": "vote",
            "args": [
              {
                "name": "proposal",
                "type": "Hash"
              },
              {
                "name": "index",
                "type": "Compact<ProposalIndex>"
              },
              {
                "name": "approve",
                "type": "bool"
              }
            ],
            "docs": [
              " Add an aye or nay vote for the sender to the given proposal.",
              "",
              " Requires the sender to be a member.",
              "",
              " Transaction fees will be waived if the member is voting on any particular proposal",
              " for the first time and the call is successful. Subsequent vote changes will charge a fee.",
              " # <weight>",
              " ## Weight",
              " - `O(M)` where `M` is members-count (code- and governance-bounded)",
              " - DB:",
              "   - 1 storage read `Members` (codec `O(M)`)",
              "   - 1 storage mutation `Voting` (codec `O(M)`)",
              " - 1 event",
              " # </weight>"
            ]
          },
          {
            "name": "close",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "index",
                "type": "Compact<ProposalIndex>"
              },
              {
                "name": "proposal_weight_bound",
                "type": "Compact<Weight>"
              },
              {
                "name": "length_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Close a vote that is either approved, disapproved or whose voting period has ended.",
              "",
              " May be called by any signed account in order to finish voting and close the proposal.",
              "",
              " If called before the end of the voting period it will only close the vote if it is",
              " has enough votes to be approved or disapproved.",
              "",
              " If called after the end of the voting period abstentions are counted as rejections",
              " unless there is a prime member set and the prime member cast an approval.",
              "",
              " If the close operation completes successfully with disapproval, the transaction fee will",
              " be waived. Otherwise execution of the approved operation will be charged to the caller.",
              "",
              " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
              " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
              "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(B + M + P1 + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - `P1` is the complexity of `proposal` preimage.",
              "   - `P2` is proposal-count (code-bounded)",
              " - DB:",
              "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
              "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
              "  - any mutations done while executing `proposal` (`P1`)",
              " - up to 3 events",
              " # </weight>"
            ]
          },
          {
            "name": "disapprove_proposal",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              }
            ],
            "docs": [
              " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
              "",
              " Must be called by the Root origin.",
              "",
              " Parameters:",
              " * `proposal_hash`: The hash of the proposal that should be disapproved.",
              "",
              " # <weight>",
              " Complexity: O(P) where P is the number of max proposals",
              " DB Weight:",
              " * Reads: Proposals",
              " * Writes: Voting, Proposals, ProposalOf",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "Proposed",
            "args": [
              "AccountId",
              "ProposalIndex",
              "Hash",
              "MemberCount"
            ],
            "docs": [
              " A motion (given hash) has been proposed (by given account) with a threshold (given",
              " `MemberCount`).",
              " \\[account, proposal_index, proposal_hash, threshold\\]"
            ]
          },
          {
            "name": "Voted",
            "args": [
              "AccountId",
              "Hash",
              "bool",
              "MemberCount",
              "MemberCount"
            ],
            "docs": [
              " A motion (given hash) has been voted on by given account, leaving",
              " a tally (yes votes and no votes given respectively as `MemberCount`).",
              " \\[account, proposal_hash, voted, yes, no\\]"
            ]
          },
          {
            "name": "Approved",
            "args": [
              "Hash"
            ],
            "docs": [
              " A motion was approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "name": "Disapproved",
            "args": [
              "Hash"
            ],
            "docs": [
              " A motion was not approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "name": "Executed",
            "args": [
              "Hash",
              "DispatchResult"
            ],
            "docs": [
              " A motion was executed; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "name": "MemberExecuted",
            "args": [
              "Hash",
              "DispatchResult"
            ],
            "docs": [
              " A single member did some action; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "name": "Closed",
            "args": [
              "Hash",
              "MemberCount",
              "MemberCount"
            ],
            "docs": [
              " A proposal was closed because its threshold was reached or after its duration was up.",
              " \\[proposal_hash, yes, no\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "NotMember",
            "docs": [
              " Account is not a member"
            ]
          },
          {
            "name": "DuplicateProposal",
            "docs": [
              " Duplicate proposals not allowed"
            ]
          },
          {
            "name": "ProposalMissing",
            "docs": [
              " Proposal must exist"
            ]
          },
          {
            "name": "WrongIndex",
            "docs": [
              " Mismatched index"
            ]
          },
          {
            "name": "DuplicateVote",
            "docs": [
              " Duplicate vote ignored"
            ]
          },
          {
            "name": "AlreadyInitialized",
            "docs": [
              " Members are already initialized!"
            ]
          },
          {
            "name": "TooEarly",
            "docs": [
              " The close call was made too early, before the end of the voting."
            ]
          },
          {
            "name": "TooManyProposals",
            "docs": [
              " There can only be a maximum of `MaxProposals` active proposals."
            ]
          },
          {
            "name": "WrongProposalWeight",
            "docs": [
              " The given weight bound for the proposal was too low."
            ]
          },
          {
            "name": "WrongProposalLength",
            "docs": [
              " The given length bound for the proposal was too low."
            ]
          }
        ],
        "index": "8"
      },
      {
        "name": "Identity",
        "storage": {
          "prefix": "Identity",
          "items": [
            {
              "name": "IdentityOf",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "Registration",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Information that is pertinent to identify the entity behind an account.",
                "",
                " TWOX-NOTE: OK â `AccountId` is a secure hash."
              ]
            },
            {
              "name": "SuperOf",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "(AccountId,Data)",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " The super-identity of an alternative \"sub\" identity together with its name, within that",
                " context. If the account is not some other account's sub-identity, then just `None`."
              ]
            },
            {
              "name": "SubsOf",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "(BalanceOf,Vec<AccountId>)",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000",
              "docs": [
                " Alternative \"sub\" identities of this account.",
                "",
                " The first item is the deposit, the second is a vector of the accounts.",
                "",
                " TWOX-NOTE: OK â `AccountId` is a secure hash."
              ]
            },
            {
              "name": "Registrars",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<Option<RegistrarInfo>>"
              },
              "fallback": "0x00",
              "docs": [
                " The set of registrars. Not expected to get very big as can only be added through a",
                " special origin (likely a council motion).",
                "",
                " The index into this can be cast to `RegistrarIndex` to get a valid value."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "add_registrar",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Add a registrar to the system.",
              "",
              " The dispatch origin for this call must be `T::RegistrarOrigin`.",
              "",
              " - `account`: the account of the registrar.",
              "",
              " Emits `RegistrarAdded` if successful.",
              "",
              " # <weight>",
              " - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).",
              " - One storage mutation (codec `O(R)`).",
              " - One event.",
              " # </weight>"
            ]
          },
          {
            "name": "set_identity",
            "args": [
              {
                "name": "info",
                "type": "IdentityInfo"
              }
            ],
            "docs": [
              " Set an account's identity information and reserve the appropriate deposit.",
              "",
              " If the account already has identity information, the deposit is taken as part payment",
              " for the new deposit.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " - `info`: The identity information.",
              "",
              " Emits `IdentitySet` if successful.",
              "",
              " # <weight>",
              " - `O(X + X' + R)`",
              "   - where `X` additional-field-count (deposit-bounded and code-bounded)",
              "   - where `R` judgements-count (registrar-count-bounded)",
              " - One balance reserve operation.",
              " - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).",
              " - One event.",
              " # </weight>"
            ]
          },
          {
            "name": "set_subs",
            "args": [
              {
                "name": "subs",
                "type": "Vec<(AccountId,Data)>"
              }
            ],
            "docs": [
              " Set the sub-accounts of the sender.",
              "",
              " Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned",
              " and an amount `SubAccountDeposit` will be reserved for each item in `subs`.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
              " identity.",
              "",
              " - `subs`: The identity's (new) sub-accounts.",
              "",
              " # <weight>",
              " - `O(P + S)`",
              "   - where `P` old-subs-count (hard- and deposit-bounded).",
              "   - where `S` subs-count (hard- and deposit-bounded).",
              " - At most one balance operations.",
              " - DB:",
              "   - `P + S` storage mutations (codec complexity `O(1)`)",
              "   - One storage read (codec complexity `O(P)`).",
              "   - One storage write (codec complexity `O(S)`).",
              "   - One storage-exists (`IdentityOf::contains_key`).",
              " # </weight>"
            ]
          },
          {
            "name": "clear_identity",
            "args": [],
            "docs": [
              " Clear an account's identity info and all sub-accounts and return all deposits.",
              "",
              " Payment: All reserved balances on the account are returned.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
              " identity.",
              "",
              " Emits `IdentityCleared` if successful.",
              "",
              " # <weight>",
              " - `O(R + S + X)`",
              "   - where `R` registrar-count (governance-bounded).",
              "   - where `S` subs-count (hard- and deposit-bounded).",
              "   - where `X` additional-field-count (deposit-bounded and code-bounded).",
              " - One balance-unreserve operation.",
              " - `2` storage reads and `S + 2` storage deletions.",
              " - One event.",
              " # </weight>"
            ]
          },
          {
            "name": "request_judgement",
            "args": [
              {
                "name": "reg_index",
                "type": "Compact<RegistrarIndex>"
              },
              {
                "name": "max_fee",
                "type": "Compact<BalanceOf>"
              }
            ],
            "docs": [
              " Request a judgement from a registrar.",
              "",
              " Payment: At most `max_fee` will be reserved for payment to the registrar if judgement",
              " given.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a",
              " registered identity.",
              "",
              " - `reg_index`: The index of the registrar whose judgement is requested.",
              " - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:",
              "",
              " ```nocompile",
              " Self::registrars().get(reg_index).unwrap().fee",
              " ```",
              "",
              " Emits `JudgementRequested` if successful.",
              "",
              " # <weight>",
              " - `O(R + X)`.",
              " - One balance-reserve operation.",
              " - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.",
              " - One event.",
              " # </weight>"
            ]
          },
          {
            "name": "cancel_request",
            "args": [
              {
                "name": "reg_index",
                "type": "RegistrarIndex"
              }
            ],
            "docs": [
              " Cancel a previous request.",
              "",
              " Payment: A previously reserved deposit is returned on success.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a",
              " registered identity.",
              "",
              " - `reg_index`: The index of the registrar whose judgement is no longer requested.",
              "",
              " Emits `JudgementUnrequested` if successful.",
              "",
              " # <weight>",
              " - `O(R + X)`.",
              " - One balance-reserve operation.",
              " - One storage mutation `O(R + X)`.",
              " - One event",
              " # </weight>"
            ]
          },
          {
            "name": "set_fee",
            "args": [
              {
                "name": "index",
                "type": "Compact<RegistrarIndex>"
              },
              {
                "name": "fee",
                "type": "Compact<BalanceOf>"
              }
            ],
            "docs": [
              " Set the fee required for a judgement to be requested from a registrar.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must be the account",
              " of the registrar whose index is `index`.",
              "",
              " - `index`: the index of the registrar whose fee is to be set.",
              " - `fee`: the new fee.",
              "",
              " # <weight>",
              " - `O(R)`.",
              " - One storage mutation `O(R)`.",
              " - Benchmark: 7.315 + R * 0.329 Âµs (min squares analysis)",
              " # </weight>"
            ]
          },
          {
            "name": "set_account_id",
            "args": [
              {
                "name": "index",
                "type": "Compact<RegistrarIndex>"
              },
              {
                "name": "new",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Change the account associated with a registrar.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must be the account",
              " of the registrar whose index is `index`.",
              "",
              " - `index`: the index of the registrar whose fee is to be set.",
              " - `new`: the new account ID.",
              "",
              " # <weight>",
              " - `O(R)`.",
              " - One storage mutation `O(R)`.",
              " - Benchmark: 8.823 + R * 0.32 Âµs (min squares analysis)",
              " # </weight>"
            ]
          },
          {
            "name": "set_fields",
            "args": [
              {
                "name": "index",
                "type": "Compact<RegistrarIndex>"
              },
              {
                "name": "fields",
                "type": "IdentityFields"
              }
            ],
            "docs": [
              " Set the field information for a registrar.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must be the account",
              " of the registrar whose index is `index`.",
              "",
              " - `index`: the index of the registrar whose fee is to be set.",
              " - `fields`: the fields that the registrar concerns themselves with.",
              "",
              " # <weight>",
              " - `O(R)`.",
              " - One storage mutation `O(R)`.",
              " - Benchmark: 7.464 + R * 0.325 Âµs (min squares analysis)",
              " # </weight>"
            ]
          },
          {
            "name": "provide_judgement",
            "args": [
              {
                "name": "reg_index",
                "type": "Compact<RegistrarIndex>"
              },
              {
                "name": "target",
                "type": "LookupSource"
              },
              {
                "name": "judgement",
                "type": "IdentityJudgement"
              }
            ],
            "docs": [
              " Provide a judgement for an account's identity.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must be the account",
              " of the registrar whose index is `reg_index`.",
              "",
              " - `reg_index`: the index of the registrar whose judgement is being made.",
              " - `target`: the account whose identity the judgement is upon. This must be an account",
              "   with a registered identity.",
              " - `judgement`: the judgement of the registrar of index `reg_index` about `target`.",
              "",
              " Emits `JudgementGiven` if successful.",
              "",
              " # <weight>",
              " - `O(R + X)`.",
              " - One balance-transfer operation.",
              " - Up to one account-lookup operation.",
              " - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.",
              " - One event.",
              " # </weight>"
            ]
          },
          {
            "name": "kill_identity",
            "args": [
              {
                "name": "target",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Remove an account's identity and sub-account information and slash the deposits.",
              "",
              " Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by",
              " `Slash`. Verification request deposits are not returned; they should be cancelled",
              " manually using `cancel_request`.",
              "",
              " The dispatch origin for this call must match `T::ForceOrigin`.",
              "",
              " - `target`: the account whose identity the judgement is upon. This must be an account",
              "   with a registered identity.",
              "",
              " Emits `IdentityKilled` if successful.",
              "",
              " # <weight>",
              " - `O(R + S + X)`.",
              " - One balance-reserve operation.",
              " - `S + 2` storage mutations.",
              " - One event.",
              " # </weight>"
            ]
          },
          {
            "name": "add_sub",
            "args": [
              {
                "name": "sub",
                "type": "LookupSource"
              },
              {
                "name": "data",
                "type": "Data"
              }
            ],
            "docs": [
              " Add the given account to the sender's subs.",
              "",
              " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
              " to the sender.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
              " sub identity of `sub`."
            ]
          },
          {
            "name": "rename_sub",
            "args": [
              {
                "name": "sub",
                "type": "LookupSource"
              },
              {
                "name": "data",
                "type": "Data"
              }
            ],
            "docs": [
              " Alter the associated name of the given sub-account.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
              " sub identity of `sub`."
            ]
          },
          {
            "name": "remove_sub",
            "args": [
              {
                "name": "sub",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Remove the given account from the sender's subs.",
              "",
              " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
              " to the sender.",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
              " sub identity of `sub`."
            ]
          },
          {
            "name": "quit_sub",
            "args": [],
            "docs": [
              " Remove the sender as a sub-account.",
              "",
              " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
              " to the sender (*not* the original depositor).",
              "",
              " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
              " super-identity.",
              "",
              " NOTE: This should not normally be used, but is provided in the case that the non-",
              " controller of an account is maliciously registered as a sub-account."
            ]
          }
        ],
        "events": [
          {
            "name": "IdentitySet",
            "args": [
              "AccountId"
            ],
            "docs": [
              " A name was set or reset (which will remove all judgements). \\[who\\]"
            ]
          },
          {
            "name": "IdentityCleared",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A name was cleared, and the given balance returned. \\[who, deposit\\]"
            ]
          },
          {
            "name": "IdentityKilled",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A name was removed and the given balance slashed. \\[who, deposit\\]"
            ]
          },
          {
            "name": "JudgementRequested",
            "args": [
              "AccountId",
              "RegistrarIndex"
            ],
            "docs": [
              " A judgement was asked from a registrar. \\[who, registrar_index\\]"
            ]
          },
          {
            "name": "JudgementUnrequested",
            "args": [
              "AccountId",
              "RegistrarIndex"
            ],
            "docs": [
              " A judgement request was retracted. \\[who, registrar_index\\]"
            ]
          },
          {
            "name": "JudgementGiven",
            "args": [
              "AccountId",
              "RegistrarIndex"
            ],
            "docs": [
              " A judgement was given by a registrar. \\[target, registrar_index\\]"
            ]
          },
          {
            "name": "RegistrarAdded",
            "args": [
              "RegistrarIndex"
            ],
            "docs": [
              " A registrar was added. \\[registrar_index\\]"
            ]
          },
          {
            "name": "SubIdentityAdded",
            "args": [
              "AccountId",
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A sub-identity was added to an identity and the deposit paid. \\[sub, main, deposit\\]"
            ]
          },
          {
            "name": "SubIdentityRemoved",
            "args": [
              "AccountId",
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A sub-identity was removed from an identity and the deposit freed.",
              " \\[sub, main, deposit\\]"
            ]
          },
          {
            "name": "SubIdentityRevoked",
            "args": [
              "AccountId",
              "AccountId",
              "Balance"
            ],
            "docs": [
              " A sub-identity was cleared, and the given deposit repatriated from the",
              " main identity account to the sub-identity account. \\[sub, main, deposit\\]"
            ]
          }
        ],
        "constants": [
          {
            "name": "BasicDeposit",
            "type": "BalanceOf",
            "value": "0x0080c6a47e8d03000000000000000000",
            "docs": [
              " The amount held on deposit for a registered identity"
            ]
          },
          {
            "name": "FieldDeposit",
            "type": "BalanceOf",
            "value": "0x00a031a95fe300000000000000000000",
            "docs": [
              " The amount held on deposit per additional field for a registered identity."
            ]
          },
          {
            "name": "SubAccountDeposit",
            "type": "BalanceOf",
            "value": "0x0080f420e6b500000000000000000000",
            "docs": [
              " The amount held on deposit for a registered subaccount. This should account for the fact",
              " that one storage item's value will increase by the size of an account ID, and there will be",
              " another trie item whose value is the size of an account ID plus 32 bytes."
            ]
          },
          {
            "name": "MaxSubAccounts",
            "type": "u32",
            "value": "0x64000000",
            "docs": [
              " The maximum number of sub-accounts allowed per identified account."
            ]
          },
          {
            "name": "MaxAdditionalFields",
            "type": "u32",
            "value": "0x64000000",
            "docs": [
              " Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O",
              " required to access an identity, but can be pretty high."
            ]
          },
          {
            "name": "MaxRegistrars",
            "type": "u32",
            "value": "0x14000000",
            "docs": [
              " Maxmimum number of registrars allowed in the system. Needed to bound the complexity",
              " of, e.g., updating judgements."
            ]
          }
        ],
        "errors": [
          {
            "name": "TooManySubAccounts",
            "docs": [
              " Too many subs-accounts."
            ]
          },
          {
            "name": "NotFound",
            "docs": [
              " Account isn't found."
            ]
          },
          {
            "name": "NotNamed",
            "docs": [
              " Account isn't named."
            ]
          },
          {
            "name": "EmptyIndex",
            "docs": [
              " Empty index."
            ]
          },
          {
            "name": "FeeChanged",
            "docs": [
              " Fee is changed."
            ]
          },
          {
            "name": "NoIdentity",
            "docs": [
              " No identity found."
            ]
          },
          {
            "name": "StickyJudgement",
            "docs": [
              " Sticky judgement."
            ]
          },
          {
            "name": "JudgementGiven",
            "docs": [
              " Judgement given."
            ]
          },
          {
            "name": "InvalidJudgement",
            "docs": [
              " Invalid judgement."
            ]
          },
          {
            "name": "InvalidIndex",
            "docs": [
              " The index is invalid."
            ]
          },
          {
            "name": "InvalidTarget",
            "docs": [
              " The target is invalid."
            ]
          },
          {
            "name": "TooManyFields",
            "docs": [
              " Too many additional fields."
            ]
          },
          {
            "name": "TooManyRegistrars",
            "docs": [
              " Maximum amount of registrars reached. Cannot add any more."
            ]
          },
          {
            "name": "AlreadyClaimed",
            "docs": [
              " Account ID is already named."
            ]
          },
          {
            "name": "NotSub",
            "docs": [
              " Sender is not a sub-account."
            ]
          },
          {
            "name": "NotOwned",
            "docs": [
              " Sub-account isn't owned by sender."
            ]
          }
        ],
        "index": "9"
      },
      {
        "name": "TechnicalCommittee",
        "storage": {
          "prefix": "Instance2Collective",
          "items": [
            {
              "name": "Proposals",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<Hash>"
              },
              "fallback": "0x00",
              "docs": [
                " The hashes of the active proposals."
              ]
            },
            {
              "name": "ProposalOf",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "Proposal",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Actual proposal for a given hash, if it's current."
              ]
            },
            {
              "name": "Voting",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Identity",
                  "key": "Hash",
                  "value": "Votes",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Votes on a given proposal, if it is ongoing."
              ]
            },
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00000000",
              "docs": [
                " Proposals so far."
              ]
            },
            {
              "name": "Members",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "docs": [
                " The current members of the collective. This is stored sorted (just by value)."
              ]
            },
            {
              "name": "Prime",
              "modifier": "Optional",
              "type": {
                "Plain": "AccountId"
              },
              "fallback": "0x00",
              "docs": [
                " The prime member that helps determine the default vote behavior in case of absentations."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "set_members",
            "args": [
              {
                "name": "new_members",
                "type": "Vec<AccountId>"
              },
              {
                "name": "prime",
                "type": "Option<AccountId>"
              },
              {
                "name": "old_count",
                "type": "MemberCount"
              }
            ],
            "docs": [
              " Set the collective's membership.",
              "",
              " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
              " - `prime`: The prime member whose vote sets the default.",
              " - `old_count`: The upper bound for the previous number of members in storage.",
              "                Used for weight estimation.",
              "",
              " Requires root origin.",
              "",
              " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
              "       the weight estimations rely on it to estimate dispatchable weight.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(MP + N)` where:",
              "   - `M` old-members-count (code- and governance-bounded)",
              "   - `N` new-members-count (code- and governance-bounded)",
              "   - `P` proposals-count (code-bounded)",
              " - DB:",
              "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
              "   - 1 storage read (codec `O(P)`) for reading the proposals",
              "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
              "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
              " # </weight>"
            ]
          },
          {
            "name": "execute",
            "args": [
              {
                "name": "proposal",
                "type": "Proposal"
              },
              {
                "name": "length_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Dispatch a proposal from a member using the `Member` origin.",
              "",
              " Origin must be a member of the collective.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
              " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
              " - 1 event",
              " # </weight>"
            ]
          },
          {
            "name": "propose",
            "args": [
              {
                "name": "threshold",
                "type": "Compact<MemberCount>"
              },
              {
                "name": "proposal",
                "type": "Proposal"
              },
              {
                "name": "length_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Add a new proposal to either be voted on or executed directly.",
              "",
              " Requires the sender to be member.",
              "",
              " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)",
              " or put up for voting.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(B + M + P1)` or `O(B + M + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - branching is influenced by `threshold` where:",
              "     - `P1` is proposal execution complexity (`threshold < 2`)",
              "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)",
              " - DB:",
              "   - 1 storage read `is_member` (codec `O(M)`)",
              "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
              "   - DB accesses influenced by `threshold`:",
              "     - EITHER storage accesses done by `proposal` (`threshold < 2`)",
              "     - OR proposal insertion (`threshold <= 2`)",
              "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
              "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
              "       - 1 storage write `ProposalOf` (codec `O(B)`)",
              "       - 1 storage write `Voting` (codec `O(M)`)",
              "   - 1 event",
              " # </weight>"
            ]
          },
          {
            "name": "vote",
            "args": [
              {
                "name": "proposal",
                "type": "Hash"
              },
              {
                "name": "index",
                "type": "Compact<ProposalIndex>"
              },
              {
                "name": "approve",
                "type": "bool"
              }
            ],
            "docs": [
              " Add an aye or nay vote for the sender to the given proposal.",
              "",
              " Requires the sender to be a member.",
              "",
              " Transaction fees will be waived if the member is voting on any particular proposal",
              " for the first time and the call is successful. Subsequent vote changes will charge a fee.",
              " # <weight>",
              " ## Weight",
              " - `O(M)` where `M` is members-count (code- and governance-bounded)",
              " - DB:",
              "   - 1 storage read `Members` (codec `O(M)`)",
              "   - 1 storage mutation `Voting` (codec `O(M)`)",
              " - 1 event",
              " # </weight>"
            ]
          },
          {
            "name": "close",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              },
              {
                "name": "index",
                "type": "Compact<ProposalIndex>"
              },
              {
                "name": "proposal_weight_bound",
                "type": "Compact<Weight>"
              },
              {
                "name": "length_bound",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Close a vote that is either approved, disapproved or whose voting period has ended.",
              "",
              " May be called by any signed account in order to finish voting and close the proposal.",
              "",
              " If called before the end of the voting period it will only close the vote if it is",
              " has enough votes to be approved or disapproved.",
              "",
              " If called after the end of the voting period abstentions are counted as rejections",
              " unless there is a prime member set and the prime member cast an approval.",
              "",
              " If the close operation completes successfully with disapproval, the transaction fee will",
              " be waived. Otherwise execution of the approved operation will be charged to the caller.",
              "",
              " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
              " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
              "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.",
              "",
              " # <weight>",
              " ## Weight",
              " - `O(B + M + P1 + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - `P1` is the complexity of `proposal` preimage.",
              "   - `P2` is proposal-count (code-bounded)",
              " - DB:",
              "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
              "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
              "  - any mutations done while executing `proposal` (`P1`)",
              " - up to 3 events",
              " # </weight>"
            ]
          },
          {
            "name": "disapprove_proposal",
            "args": [
              {
                "name": "proposal_hash",
                "type": "Hash"
              }
            ],
            "docs": [
              " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
              "",
              " Must be called by the Root origin.",
              "",
              " Parameters:",
              " * `proposal_hash`: The hash of the proposal that should be disapproved.",
              "",
              " # <weight>",
              " Complexity: O(P) where P is the number of max proposals",
              " DB Weight:",
              " * Reads: Proposals",
              " * Writes: Voting, Proposals, ProposalOf",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "Proposed",
            "args": [
              "AccountId",
              "ProposalIndex",
              "Hash",
              "MemberCount"
            ],
            "docs": [
              " A motion (given hash) has been proposed (by given account) with a threshold (given",
              " `MemberCount`).",
              " \\[account, proposal_index, proposal_hash, threshold\\]"
            ]
          },
          {
            "name": "Voted",
            "args": [
              "AccountId",
              "Hash",
              "bool",
              "MemberCount",
              "MemberCount"
            ],
            "docs": [
              " A motion (given hash) has been voted on by given account, leaving",
              " a tally (yes votes and no votes given respectively as `MemberCount`).",
              " \\[account, proposal_hash, voted, yes, no\\]"
            ]
          },
          {
            "name": "Approved",
            "args": [
              "Hash"
            ],
            "docs": [
              " A motion was approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "name": "Disapproved",
            "args": [
              "Hash"
            ],
            "docs": [
              " A motion was not approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "name": "Executed",
            "args": [
              "Hash",
              "DispatchResult"
            ],
            "docs": [
              " A motion was executed; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "name": "MemberExecuted",
            "args": [
              "Hash",
              "DispatchResult"
            ],
            "docs": [
              " A single member did some action; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "name": "Closed",
            "args": [
              "Hash",
              "MemberCount",
              "MemberCount"
            ],
            "docs": [
              " A proposal was closed because its threshold was reached or after its duration was up.",
              " \\[proposal_hash, yes, no\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "NotMember",
            "docs": [
              " Account is not a member"
            ]
          },
          {
            "name": "DuplicateProposal",
            "docs": [
              " Duplicate proposals not allowed"
            ]
          },
          {
            "name": "ProposalMissing",
            "docs": [
              " Proposal must exist"
            ]
          },
          {
            "name": "WrongIndex",
            "docs": [
              " Mismatched index"
            ]
          },
          {
            "name": "DuplicateVote",
            "docs": [
              " Duplicate vote ignored"
            ]
          },
          {
            "name": "AlreadyInitialized",
            "docs": [
              " Members are already initialized!"
            ]
          },
          {
            "name": "TooEarly",
            "docs": [
              " The close call was made too early, before the end of the voting."
            ]
          },
          {
            "name": "TooManyProposals",
            "docs": [
              " There can only be a maximum of `MaxProposals` active proposals."
            ]
          },
          {
            "name": "WrongProposalWeight",
            "docs": [
              " The given weight bound for the proposal was too low."
            ]
          },
          {
            "name": "WrongProposalLength",
            "docs": [
              " The given length bound for the proposal was too low."
            ]
          }
        ],
        "index": "10"
      },
      {
        "name": "Proxy",
        "storage": {
          "prefix": "Proxy",
          "items": [
            {
              "name": "Proxies",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "(Vec<ProxyDefinition>,BalanceOf)",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000",
              "docs": [
                " The set of account proxies. Maps the account which has delegated to the accounts",
                " which are being delegated to, together with the amount held on deposit."
              ]
            },
            {
              "name": "Announcements",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "(Vec<ProxyAnnouncement>,BalanceOf)",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000",
              "docs": [
                " The announcements made by the proxy (key)."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "proxy",
            "args": [
              {
                "name": "real",
                "type": "AccountId"
              },
              {
                "name": "force_proxy_type",
                "type": "Option<ProxyType>"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Dispatch the given `call` from an account that the sender is authorised for through",
              " `add_proxy`.",
              "",
              " Removes any corresponding announcement(s).",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
              " - `call`: The call to be made by the `real` account.",
              "",
              " # <weight>",
              " Weight is a function of the number of proxies the user has (P).",
              " # </weight>"
            ]
          },
          {
            "name": "add_proxy",
            "args": [
              {
                "name": "delegate",
                "type": "AccountId"
              },
              {
                "name": "proxy_type",
                "type": "ProxyType"
              },
              {
                "name": "delay",
                "type": "BlockNumber"
              }
            ],
            "docs": [
              " Register a proxy account for the sender that is able to make calls on its behalf.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `proxy`: The account that the `caller` would like to make a proxy.",
              " - `proxy_type`: The permissions allowed for this proxy account.",
              " - `delay`: The announcement period required of the initial proxy. Will generally be",
              " zero.",
              "",
              " # <weight>",
              " Weight is a function of the number of proxies the user has (P).",
              " # </weight>"
            ]
          },
          {
            "name": "remove_proxy",
            "args": [
              {
                "name": "delegate",
                "type": "AccountId"
              },
              {
                "name": "proxy_type",
                "type": "ProxyType"
              },
              {
                "name": "delay",
                "type": "BlockNumber"
              }
            ],
            "docs": [
              " Unregister a proxy account for the sender.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `proxy`: The account that the `caller` would like to remove as a proxy.",
              " - `proxy_type`: The permissions currently enabled for the removed proxy account.",
              "",
              " # <weight>",
              " Weight is a function of the number of proxies the user has (P).",
              " # </weight>"
            ]
          },
          {
            "name": "remove_proxies",
            "args": [],
            "docs": [
              " Unregister all proxy accounts for the sender.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " WARNING: This may be called on accounts created by `anonymous`, however if done, then",
              " the unreserved fees will be inaccessible. **All access to this account will be lost.**",
              "",
              " # <weight>",
              " Weight is a function of the number of proxies the user has (P).",
              " # </weight>"
            ]
          },
          {
            "name": "anonymous",
            "args": [
              {
                "name": "proxy_type",
                "type": "ProxyType"
              },
              {
                "name": "delay",
                "type": "BlockNumber"
              },
              {
                "name": "index",
                "type": "u16"
              }
            ],
            "docs": [
              " Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and",
              " initialize it with a proxy of `proxy_type` for `origin` sender.",
              "",
              " Requires a `Signed` origin.",
              "",
              " - `proxy_type`: The type of the proxy that the sender will be registered as over the",
              " new account. This will almost always be the most permissive `ProxyType` possible to",
              " allow for maximum flexibility.",
              " - `index`: A disambiguation index, in case this is called multiple times in the same",
              " transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just",
              " want to use `0`.",
              " - `delay`: The announcement period required of the initial proxy. Will generally be",
              " zero.",
              "",
              " Fails with `Duplicate` if this has already been called in this transaction, from the",
              " same sender, with the same parameters.",
              "",
              " Fails if there are insufficient funds to pay for deposit.",
              "",
              " # <weight>",
              " Weight is a function of the number of proxies the user has (P).",
              " # </weight>",
              " TODO: Might be over counting 1 read"
            ]
          },
          {
            "name": "kill_anonymous",
            "args": [
              {
                "name": "spawner",
                "type": "AccountId"
              },
              {
                "name": "proxy_type",
                "type": "ProxyType"
              },
              {
                "name": "index",
                "type": "u16"
              },
              {
                "name": "height",
                "type": "Compact<BlockNumber>"
              },
              {
                "name": "ext_index",
                "type": "Compact<u32>"
              }
            ],
            "docs": [
              " Removes a previously spawned anonymous proxy.",
              "",
              " WARNING: **All access to this account will be lost.** Any funds held in it will be",
              " inaccessible.",
              "",
              " Requires a `Signed` origin, and the sender account must have been created by a call to",
              " `anonymous` with corresponding parameters.",
              "",
              " - `spawner`: The account that originally called `anonymous` to create this account.",
              " - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.",
              " - `proxy_type`: The proxy type originally passed to `anonymous`.",
              " - `height`: The height of the chain when the call to `anonymous` was processed.",
              " - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.",
              "",
              " Fails with `NoPermission` in case the caller is not a previously created anonymous",
              " account whose `anonymous` call has corresponding parameters.",
              "",
              " # <weight>",
              " Weight is a function of the number of proxies the user has (P).",
              " # </weight>"
            ]
          },
          {
            "name": "announce",
            "args": [
              {
                "name": "real",
                "type": "AccountId"
              },
              {
                "name": "call_hash",
                "type": "CallHashOf"
              }
            ],
            "docs": [
              " Publish the hash of a proxy-call that will be made in the future.",
              "",
              " This must be called some number of blocks before the corresponding `proxy` is attempted",
              " if the delay associated with the proxy relationship is greater than zero.",
              "",
              " No more than `MaxPending` announcements may be made at any one time.",
              "",
              " This will take a deposit of `AnnouncementDepositFactor` as well as",
              " `AnnouncementDepositBase` if there are no other pending announcements.",
              "",
              " The dispatch origin for this call must be _Signed_ and a proxy of `real`.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `call_hash`: The hash of the call to be made by the `real` account.",
              "",
              " # <weight>",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # </weight>"
            ]
          },
          {
            "name": "remove_announcement",
            "args": [
              {
                "name": "real",
                "type": "AccountId"
              },
              {
                "name": "call_hash",
                "type": "CallHashOf"
              }
            ],
            "docs": [
              " Remove a given announcement.",
              "",
              " May be called by a proxy account to remove a call they previously announced and return",
              " the deposit.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `call_hash`: The hash of the call to be made by the `real` account.",
              "",
              " # <weight>",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # </weight>"
            ]
          },
          {
            "name": "reject_announcement",
            "args": [
              {
                "name": "delegate",
                "type": "AccountId"
              },
              {
                "name": "call_hash",
                "type": "CallHashOf"
              }
            ],
            "docs": [
              " Remove the given announcement of a delegate.",
              "",
              " May be called by a target (proxied) account to remove a call that one of their delegates",
              " (`delegate`) has announced they want to execute. The deposit is returned.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `delegate`: The account that previously announced the call.",
              " - `call_hash`: The hash of the call to be made.",
              "",
              " # <weight>",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # </weight>"
            ]
          },
          {
            "name": "proxy_announced",
            "args": [
              {
                "name": "delegate",
                "type": "AccountId"
              },
              {
                "name": "real",
                "type": "AccountId"
              },
              {
                "name": "force_proxy_type",
                "type": "Option<ProxyType>"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Dispatch the given `call` from an account that the sender is authorized for through",
              " `add_proxy`.",
              "",
              " Removes any corresponding announcement(s).",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
              " - `call`: The call to be made by the `real` account.",
              "",
              " # <weight>",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "ProxyExecuted",
            "args": [
              "DispatchResult"
            ],
            "docs": [
              " A proxy was executed correctly, with the given \\[result\\]."
            ]
          },
          {
            "name": "AnonymousCreated",
            "args": [
              "AccountId",
              "AccountId",
              "ProxyType",
              "u16"
            ],
            "docs": [
              " Anonymous account has been created by new proxy with given",
              " disambiguation index and proxy type. \\[anonymous, who, proxy_type, disambiguation_index\\]"
            ]
          },
          {
            "name": "Announced",
            "args": [
              "AccountId",
              "AccountId",
              "Hash"
            ],
            "docs": [
              " An announcement was placed to make a call in the future. \\[real, proxy, call_hash\\]"
            ]
          }
        ],
        "constants": [
          {
            "name": "ProxyDepositBase",
            "type": "BalanceOf",
            "value": "0x00f09e544c3900000000000000000000",
            "docs": [
              " The base amount of currency needed to reserve for creating a proxy.",
              "",
              " This is held for an additional storage item whose value size is",
              " `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes."
            ]
          },
          {
            "name": "ProxyDepositFactor",
            "type": "BalanceOf",
            "value": "0x0060aa7714b400000000000000000000",
            "docs": [
              " The amount of currency needed per proxy added.",
              "",
              " This is held for adding 32 bytes plus an instance of `ProxyType` more into a pre-existing",
              " storage value. Thus, when configuring `ProxyDepositFactor` one should take into account",
              " `32 + proxy_type.encode().len()` bytes of data."
            ]
          },
          {
            "name": "MaxProxies",
            "type": "u32",
            "value": "0x20000000",
            "docs": [
              " The maximum amount of proxies allowed for a single account."
            ]
          },
          {
            "name": "MaxPending",
            "type": "u32",
            "value": "0x20000000",
            "docs": [
              " The maximum amount of time-delayed announcements that are allowed to be pending."
            ]
          },
          {
            "name": "AnnouncementDepositBase",
            "type": "BalanceOf",
            "value": "0x00f09e544c3900000000000000000000",
            "docs": [
              " The base amount of currency needed to reserve for creating an announcement.",
              "",
              " This is held when a new storage item holding a `Balance` is created (typically 16 bytes)."
            ]
          },
          {
            "name": "AnnouncementDepositFactor",
            "type": "BalanceOf",
            "value": "0x00c054ef286801000000000000000000",
            "docs": [
              " The amount of currency needed per announcement made.",
              "",
              " This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)",
              " into a pre-existing storage value."
            ]
          }
        ],
        "errors": [
          {
            "name": "TooMany",
            "docs": [
              " There are too many proxies registered or too many announcements pending."
            ]
          },
          {
            "name": "NotFound",
            "docs": [
              " Proxy registration not found."
            ]
          },
          {
            "name": "NotProxy",
            "docs": [
              " Sender is not a proxy of the account to be proxied."
            ]
          },
          {
            "name": "Unproxyable",
            "docs": [
              " A call which is incompatible with the proxy type's filter was attempted."
            ]
          },
          {
            "name": "Duplicate",
            "docs": [
              " Account is already a proxy."
            ]
          },
          {
            "name": "NoPermission",
            "docs": [
              " Call may not be made by proxy because it may escalate its privileges."
            ]
          },
          {
            "name": "Unannounced",
            "docs": [
              " Announcement, if made at all, was made too recently."
            ]
          },
          {
            "name": "NoSelfProxy",
            "docs": [
              " Cannot add self as proxy."
            ]
          }
        ],
        "index": "11"
      },
      {
        "name": "Recovery",
        "storage": {
          "prefix": "Recovery",
          "items": [
            {
              "name": "Recoverable",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "AccountId",
                  "value": "RecoveryConfig",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " The set of recoverable accounts and their recovery configuration."
              ]
            },
            {
              "name": "ActiveRecoveries",
              "modifier": "Optional",
              "type": {
                "DoubleMap": {
                  "hasher": "Twox64Concat",
                  "key1": "AccountId",
                  "key2": "AccountId",
                  "value": "ActiveRecovery",
                  "key2Hasher": "Twox64Concat"
                }
              },
              "fallback": "0x00",
              "docs": [
                " Active recovery attempts.",
                "",
                " First account is the account to be recovered, and the second account",
                " is the user trying to recover the account."
              ]
            },
            {
              "name": "Proxy",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "AccountId",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " The list of allowed proxy accounts.",
                "",
                " Map from the user who can access it to the recovered account."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "as_recovered",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              },
              {
                "name": "call",
                "type": "Call"
              }
            ],
            "docs": [
              " Send a call through a recovered account.",
              "",
              " The dispatch origin for this call must be _Signed_ and registered to",
              " be able to make calls on behalf of the recovered account.",
              "",
              " Parameters:",
              " - `account`: The recovered account you want to make a call on-behalf-of.",
              " - `call`: The call you want to make with the recovered account.",
              "",
              " # <weight>",
              " - The weight of the `call` + 10,000.",
              " - One storage lookup to check account is recovered by `who`. O(1)",
              " # </weight>"
            ]
          },
          {
            "name": "set_recovered",
            "args": [
              {
                "name": "lost",
                "type": "AccountId"
              },
              {
                "name": "rescuer",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Allow ROOT to bypass the recovery process and set an a rescuer account",
              " for a lost account directly.",
              "",
              " The dispatch origin for this call must be _ROOT_.",
              "",
              " Parameters:",
              " - `lost`: The \"lost account\" to be recovered.",
              " - `rescuer`: The \"rescuer account\" which can call as the lost account.",
              "",
              " # <weight>",
              " - One storage write O(1)",
              " - One event",
              " # </weight>"
            ]
          },
          {
            "name": "create_recovery",
            "args": [
              {
                "name": "friends",
                "type": "Vec<AccountId>"
              },
              {
                "name": "threshold",
                "type": "u16"
              },
              {
                "name": "delay_period",
                "type": "BlockNumber"
              }
            ],
            "docs": [
              " Create a recovery configuration for your account. This makes your account recoverable.",
              "",
              " Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance",
              " will be reserved for storing the recovery configuration. This deposit is returned",
              " in full when the user calls `remove_recovery`.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `friends`: A list of friends you trust to vouch for recovery attempts.",
              "   Should be ordered and contain no duplicate values.",
              " - `threshold`: The number of friends that must vouch for a recovery attempt",
              "   before the account can be recovered. Should be less than or equal to",
              "   the length of the list of friends.",
              " - `delay_period`: The number of blocks after a recovery attempt is initialized",
              "   that needs to pass before the account can be recovered.",
              "",
              " # <weight>",
              " - Key: F (len of friends)",
              " - One storage read to check that account is not already recoverable. O(1).",
              " - A check that the friends list is sorted and unique. O(F)",
              " - One currency reserve operation. O(X)",
              " - One storage write. O(1). Codec O(F).",
              " - One event.",
              "",
              " Total Complexity: O(F + X)",
              " # </weight>"
            ]
          },
          {
            "name": "initiate_recovery",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Initiate the process for recovering a recoverable account.",
              "",
              " Payment: `RecoveryDeposit` balance will be reserved for initiating the",
              " recovery process. This deposit will always be repatriated to the account",
              " trying to be recovered. See `close_recovery`.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `account`: The lost account that you want to recover. This account",
              "   needs to be recoverable (i.e. have a recovery configuration).",
              "",
              " # <weight>",
              " - One storage read to check that account is recoverable. O(F)",
              " - One storage read to check that this recovery process hasn't already started. O(1)",
              " - One currency reserve operation. O(X)",
              " - One storage read to get the current block number. O(1)",
              " - One storage write. O(1).",
              " - One event.",
              "",
              " Total Complexity: O(F + X)",
              " # </weight>"
            ]
          },
          {
            "name": "vouch_recovery",
            "args": [
              {
                "name": "lost",
                "type": "AccountId"
              },
              {
                "name": "rescuer",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Allow a \"friend\" of a recoverable account to vouch for an active recovery",
              " process for that account.",
              "",
              " The dispatch origin for this call must be _Signed_ and must be a \"friend\"",
              " for the recoverable account.",
              "",
              " Parameters:",
              " - `lost`: The lost account that you want to recover.",
              " - `rescuer`: The account trying to rescue the lost account that you",
              "   want to vouch for.",
              "",
              " The combination of these two parameters must point to an active recovery",
              " process.",
              "",
              " # <weight>",
              " Key: F (len of friends in config), V (len of vouching friends)",
              " - One storage read to get the recovery configuration. O(1), Codec O(F)",
              " - One storage read to get the active recovery process. O(1), Codec O(V)",
              " - One binary search to confirm caller is a friend. O(logF)",
              " - One binary search to confirm caller has not already vouched. O(logV)",
              " - One storage write. O(1), Codec O(V).",
              " - One event.",
              "",
              " Total Complexity: O(F + logF + V + logV)",
              " # </weight>"
            ]
          },
          {
            "name": "claim_recovery",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Allow a successful rescuer to claim their recovered account.",
              "",
              " The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"",
              " who has successfully completed the account recovery process: collected",
              " `threshold` or more vouches, waited `delay_period` blocks since initiation.",
              "",
              " Parameters:",
              " - `account`: The lost account that you want to claim has been successfully",
              "   recovered by you.",
              "",
              " # <weight>",
              " Key: F (len of friends in config), V (len of vouching friends)",
              " - One storage read to get the recovery configuration. O(1), Codec O(F)",
              " - One storage read to get the active recovery process. O(1), Codec O(V)",
              " - One storage read to get the current block number. O(1)",
              " - One storage write. O(1), Codec O(V).",
              " - One event.",
              "",
              " Total Complexity: O(F + V)",
              " # </weight>"
            ]
          },
          {
            "name": "close_recovery",
            "args": [
              {
                "name": "rescuer",
                "type": "AccountId"
              }
            ],
            "docs": [
              " As the controller of a recoverable account, close an active recovery",
              " process for your account.",
              "",
              " Payment: By calling this function, the recoverable account will receive",
              " the recovery deposit `RecoveryDeposit` placed by the rescuer.",
              "",
              " The dispatch origin for this call must be _Signed_ and must be a",
              " recoverable account with an active recovery process for it.",
              "",
              " Parameters:",
              " - `rescuer`: The account trying to rescue this recoverable account.",
              "",
              " # <weight>",
              " Key: V (len of vouching friends)",
              " - One storage read/remove to get the active recovery process. O(1), Codec O(V)",
              " - One balance call to repatriate reserved. O(X)",
              " - One event.",
              "",
              " Total Complexity: O(V + X)",
              " # </weight>"
            ]
          },
          {
            "name": "remove_recovery",
            "args": [],
            "docs": [
              " Remove the recovery process for your account. Recovered accounts are still accessible.",
              "",
              " NOTE: The user must make sure to call `close_recovery` on all active",
              " recovery attempts before calling this function else it will fail.",
              "",
              " Payment: By calling this function the recoverable account will unreserve",
              " their recovery configuration deposit.",
              " (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)",
              "",
              " The dispatch origin for this call must be _Signed_ and must be a",
              " recoverable account (i.e. has a recovery configuration).",
              "",
              " # <weight>",
              " Key: F (len of friends)",
              " - One storage read to get the prefix iterator for active recoveries. O(1)",
              " - One storage read/remove to get the recovery configuration. O(1), Codec O(F)",
              " - One balance call to unreserved. O(X)",
              " - One event.",
              "",
              " Total Complexity: O(F + X)",
              " # </weight>"
            ]
          },
          {
            "name": "cancel_recovered",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Cancel the ability to use `as_recovered` for `account`.",
              "",
              " The dispatch origin for this call must be _Signed_ and registered to",
              " be able to make calls on behalf of the recovered account.",
              "",
              " Parameters:",
              " - `account`: The recovered account you are able to call on-behalf-of.",
              "",
              " # <weight>",
              " - One storage mutation to check account is recovered by `who`. O(1)",
              " # </weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "RecoveryCreated",
            "args": [
              "AccountId"
            ],
            "docs": [
              " A recovery process has been set up for an \\[account\\]."
            ]
          },
          {
            "name": "RecoveryInitiated",
            "args": [
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " A recovery process has been initiated for lost account by rescuer account.",
              " \\[lost, rescuer\\]"
            ]
          },
          {
            "name": "RecoveryVouched",
            "args": [
              "AccountId",
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " A recovery process for lost account by rescuer account has been vouched for by sender.",
              " \\[lost, rescuer, sender\\]"
            ]
          },
          {
            "name": "RecoveryClosed",
            "args": [
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " A recovery process for lost account by rescuer account has been closed.",
              " \\[lost, rescuer\\]"
            ]
          },
          {
            "name": "AccountRecovered",
            "args": [
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " Lost account has been successfully recovered by rescuer account.",
              " \\[lost, rescuer\\]"
            ]
          },
          {
            "name": "RecoveryRemoved",
            "args": [
              "AccountId"
            ],
            "docs": [
              " A recovery process has been removed for an \\[account\\]."
            ]
          }
        ],
        "constants": [
          {
            "name": "ConfigDepositBase",
            "type": "BalanceOf",
            "value": "0x00406352bfc601000000000000000000",
            "docs": [
              " The base amount of currency needed to reserve for creating a recovery configuration.",
              "",
              " This is held for an additional storage item whose value size is",
              " `2 + sizeof(BlockNumber, Balance)` bytes."
            ]
          },
          {
            "name": "FriendDepositFactor",
            "type": "BalanceOf",
            "value": "0x00203d88792d00000000000000000000",
            "docs": [
              " The amount of currency needed per additional user when creating a recovery configuration.",
              "",
              " This is held for adding `sizeof(AccountId)` bytes more into a pre-existing storage value."
            ]
          },
          {
            "name": "MaxFriends",
            "type": "u16",
            "value": "0x0900",
            "docs": [
              " The maximum amount of friends allowed in a recovery configuration."
            ]
          },
          {
            "name": "RecoveryDeposit",
            "type": "BalanceOf",
            "value": "0x00406352bfc601000000000000000000",
            "docs": [
              " The base amount of currency needed to reserve for starting a recovery.",
              "",
              " This is primarily held for deterring malicious recovery attempts, and should",
              " have a value large enough that a bad actor would choose not to place this",
              " deposit. It also acts to fund additional storage item whose value size is",
              " `sizeof(BlockNumber, Balance + T * AccountId)` bytes. Where T is a configurable",
              " threshold."
            ]
          }
        ],
        "errors": [
          {
            "name": "NotAllowed",
            "docs": [
              " User is not allowed to make a call on behalf of this account"
            ]
          },
          {
            "name": "ZeroThreshold",
            "docs": [
              " Threshold must be greater than zero"
            ]
          },
          {
            "name": "NotEnoughFriends",
            "docs": [
              " Friends list must be greater than zero and threshold"
            ]
          },
          {
            "name": "MaxFriends",
            "docs": [
              " Friends list must be less than max friends"
            ]
          },
          {
            "name": "NotSorted",
            "docs": [
              " Friends list must be sorted and free of duplicates"
            ]
          },
          {
            "name": "NotRecoverable",
            "docs": [
              " This account is not set up for recovery"
            ]
          },
          {
            "name": "AlreadyRecoverable",
            "docs": [
              " This account is already set up for recovery"
            ]
          },
          {
            "name": "AlreadyStarted",
            "docs": [
              " A recovery process has already started for this account"
            ]
          },
          {
            "name": "NotStarted",
            "docs": [
              " A recovery process has not started for this rescuer"
            ]
          },
          {
            "name": "NotFriend",
            "docs": [
              " This account is not a friend who can vouch"
            ]
          },
          {
            "name": "DelayPeriod",
            "docs": [
              " The friend must wait until the delay period to vouch for this recovery"
            ]
          },
          {
            "name": "AlreadyVouched",
            "docs": [
              " This user has already vouched for this recovery"
            ]
          },
          {
            "name": "Threshold",
            "docs": [
              " The threshold for recovering this account has not been met"
            ]
          },
          {
            "name": "StillActive",
            "docs": [
              " There are still active recovery attempts that need to be closed"
            ]
          },
          {
            "name": "AlreadyProxy",
            "docs": [
              " This account is already set up for recovery"
            ]
          },
          {
            "name": "BadState",
            "docs": [
              " Some internal state is broken."
            ]
          }
        ],
        "index": "12"
      },
      {
        "name": "ParachainSystem",
        "storage": {
          "prefix": "ParachainSystem",
          "items": [
            {
              "name": "PendingRelayChainBlockNumber",
              "modifier": "Optional",
              "type": {
                "Plain": "RelayChainBlockNumber"
              },
              "fallback": "0x00",
              "docs": [
                " We need to store the new validation function for the span between",
                " setting it and applying it. If it has a",
                " value, then [`PendingValidationCode`] must have a real value, and",
                " together will coordinate the block number where the upgrade will happen."
              ]
            },
            {
              "name": "PendingValidationCode",
              "modifier": "Default",
              "type": {
                "Plain": "Bytes"
              },
              "fallback": "0x00",
              "docs": [
                " The new validation function we will upgrade to when the relay chain",
                " reaches [`PendingRelayChainBlockNumber`]. A real validation function must",
                " exist here as long as [`PendingRelayChainBlockNumber`] is set."
              ]
            },
            {
              "name": "ValidationData",
              "modifier": "Optional",
              "type": {
                "Plain": "PersistedValidationData"
              },
              "fallback": "0x00",
              "docs": [
                " The [`PersistedValidationData`] set for this block."
              ]
            },
            {
              "name": "DidSetValidationCode",
              "modifier": "Default",
              "type": {
                "Plain": "bool"
              },
              "fallback": "0x00",
              "docs": [
                " Were the validation data set to notify the relay chain?"
              ]
            },
            {
              "name": "LastUpgrade",
              "modifier": "Default",
              "type": {
                "Plain": "BlockNumber"
              },
              "fallback": "0x00000000",
              "docs": [
                " The last relay parent block number at which we signalled the code upgrade."
              ]
            },
            {
              "name": "RelevantMessagingState",
              "modifier": "Optional",
              "type": {
                "Plain": "MessagingStateSnapshot"
              },
              "fallback": "0x00",
              "docs": [
                " The snapshot of some state related to messaging relevant to the current parachain as per",
                " the relay parent.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "name": "HostConfiguration",
              "modifier": "Optional",
              "type": {
                "Plain": "AbridgedHostConfiguration"
              },
              "fallback": "0x00",
              "docs": [
                " The parachain host configuration that was obtained from the relay parent.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "name": "LastDmqMqcHead",
              "modifier": "Default",
              "type": {
                "Plain": "MessageQueueChain"
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The last downward message queue chain head we have observed.",
                "",
                " This value is loaded before and saved after processing inbound downward messages carried",
                " by the system inherent."
              ]
            },
            {
              "name": "LastHrmpMqcHeads",
              "modifier": "Default",
              "type": {
                "Plain": "BTreeMap<ParaId,MessageQueueChain>"
              },
              "fallback": "0x00",
              "docs": [
                " The message queue chain heads we have observed per each channel incoming channel.",
                "",
                " This value is loaded before and saved after processing inbound downward messages carried",
                " by the system inherent."
              ]
            },
            {
              "name": "ProcessedDownwardMessages",
              "modifier": "Default",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00000000",
              "docs": [
                " Number of downward messages processed in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "NewValidationCode",
              "modifier": "Optional",
              "type": {
                "Plain": "Bytes"
              },
              "fallback": "0x00",
              "docs": [
                " New validation code that was set in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block if no other pallet already set",
                " the value."
              ]
            },
            {
              "name": "HrmpWatermark",
              "modifier": "Default",
              "type": {
                "Plain": "BlockNumber"
              },
              "fallback": "0x00000000",
              "docs": [
                " HRMP watermark that was set in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "HrmpOutboundMessages",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<OutboundHrmpMessage>"
              },
              "fallback": "0x00",
              "docs": [
                " HRMP messages that were sent in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "UpwardMessages",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<UpwardMessage>"
              },
              "fallback": "0x00",
              "docs": [
                " Upward messages that were sent in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "PendingUpwardMessages",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<UpwardMessage>"
              },
              "fallback": "0x00",
              "docs": [
                " Upward messages that are still pending and not yet send to the relay chain."
              ]
            },
            {
              "name": "AnnouncedHrmpMessagesPerCandidate",
              "modifier": "Default",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00000000",
              "docs": [
                " The number of HRMP messages we observed in `on_initialize` and thus used that number for",
                " announcing the weight of `on_initialize` and `on_finalize`."
              ]
            },
            {
              "name": "ReservedXcmpWeightOverride",
              "modifier": "Optional",
              "type": {
                "Plain": "Weight"
              },
              "fallback": "0x00",
              "docs": [
                " The weight we reserve at the beginning of the block for processing XCMP messages. This",
                " overrides the amount set in the Config trait."
              ]
            },
            {
              "name": "ReservedDmpWeightOverride",
              "modifier": "Optional",
              "type": {
                "Plain": "Weight"
              },
              "fallback": "0x00",
              "docs": [
                " The weight we reserve at the beginning of the block for processing DMP messages. This",
                " overrides the amount set in the Config trait."
              ]
            },
            {
              "name": "AuthorizedUpgrade",
              "modifier": "Optional",
              "type": {
                "Plain": "Hash"
              },
              "fallback": "0x00",
              "docs": [
                " The next authorized upgrade, if there is one."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "set_upgrade_block",
            "args": [
              {
                "name": "relay_chain_block",
                "type": "RelayChainBlockNumber"
              }
            ],
            "docs": [
              " Force an already scheduled validation function upgrade to happen on a particular block.",
              "",
              " Note that coordinating this block for the upgrade has to happen independently on the",
              " relay chain and this parachain. Synchronizing the block for the upgrade is sensitive,",
              " and this bypasses all checks and and normal protocols. Very easy to brick your chain",
              " if done wrong."
            ]
          },
          {
            "name": "set_validation_data",
            "args": [
              {
                "name": "data",
                "type": "ParachainInherentData"
              }
            ],
            "docs": [
              " Set the current validation data.",
              "",
              " This should be invoked exactly once per block. It will panic at the finalization",
              " phase if the call was not invoked.",
              "",
              " The dispatch origin for this call must be `Inherent`",
              "",
              " As a side effect, this function upgrades the current validation function",
              " if the appropriate time has come."
            ]
          },
          {
            "name": "sudo_send_upward_message",
            "args": [
              {
                "name": "message",
                "type": "UpwardMessage"
              }
            ],
            "docs": []
          },
          {
            "name": "authorize_upgrade",
            "args": [
              {
                "name": "code_hash",
                "type": "Hash"
              }
            ],
            "docs": []
          },
          {
            "name": "enact_authorized_upgrade",
            "args": [
              {
                "name": "code",
                "type": "Bytes"
              }
            ],
            "docs": []
          }
        ],
        "events": [
          {
            "name": "ValidationFunctionStored",
            "args": [
              "RelayChainBlockNumber"
            ],
            "docs": [
              " The validation function has been scheduled to apply as of the contained relay chain",
              " block number."
            ]
          },
          {
            "name": "ValidationFunctionApplied",
            "args": [
              "RelayChainBlockNumber"
            ],
            "docs": [
              " The validation function was applied as of the contained relay chain block number."
            ]
          },
          {
            "name": "UpgradeAuthorized",
            "args": [
              "Hash"
            ],
            "docs": [
              " An upgrade has been authorized."
            ]
          },
          {
            "name": "DownwardMessagesReceived",
            "args": [
              "u32"
            ],
            "docs": [
              " Some downward messages have been received and will be processed.",
              " \\[ count \\]"
            ]
          },
          {
            "name": "DownwardMessagesProcessed",
            "args": [
              "Weight",
              "Hash"
            ],
            "docs": [
              " Downward messages were processed using the given weight.",
              " \\[ weight_used, result_mqc_head \\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "OverlappingUpgrades",
            "docs": [
              " Attempt to upgrade validation function while existing upgrade pending"
            ]
          },
          {
            "name": "ProhibitedByPolkadot",
            "docs": [
              " Polkadot currently prohibits this parachain from upgrading its validation function"
            ]
          },
          {
            "name": "TooBig",
            "docs": [
              " The supplied validation function has compiled into a blob larger than Polkadot is",
              " willing to run"
            ]
          },
          {
            "name": "ValidationDataNotAvailable",
            "docs": [
              " The inherent which supplies the validation data did not run this block"
            ]
          },
          {
            "name": "HostConfigurationNotAvailable",
            "docs": [
              " The inherent which supplies the host configuration did not run this block"
            ]
          },
          {
            "name": "NotScheduled",
            "docs": [
              " No validation function upgrade is currently scheduled."
            ]
          },
          {
            "name": "NothingAuthorized",
            "docs": [
              " No code upgrade has been authorized."
            ]
          },
          {
            "name": "Unauthorized",
            "docs": [
              " The given code upgrade has not been authorized."
            ]
          }
        ],
        "index": "20"
      },
      {
        "name": "ParachainInfo",
        "storage": {
          "prefix": "ParachainInfo",
          "items": [
            {
              "name": "ParachainId",
              "modifier": "Default",
              "type": {
                "Plain": "ParaId"
              },
              "fallback": "0x64000000",
              "docs": []
            }
          ]
        },
        "calls": null,
        "events": null,
        "constants": [],
        "errors": [],
        "index": "21"
      },
      {
        "name": "Balances",
        "storage": {
          "prefix": "Balances",
          "items": [
            {
              "name": "TotalIssuance",
              "modifier": "Default",
              "type": {
                "Plain": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total units issued in the system."
              ]
            },
            {
              "name": "Account",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "AccountData",
                  "linked": false
                }
              },
              "fallback": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The balance of an account.",
                "",
                " NOTE: This is only used in the case that this pallet is used to store balances."
              ]
            },
            {
              "name": "Locks",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Vec<BalanceLock>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Any liquidity locks on some account balances.",
                " NOTE: Should only be accessed when setting, changing and freeing a lock."
              ]
            },
            {
              "name": "Reserves",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Vec<ReserveData>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Named reserves on some account balances."
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "Plain": "Releases"
              },
              "fallback": "0x00",
              "docs": [
                " Storage version of the pallet.",
                "",
                " This is set to v2.0.0 for new networks."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "transfer",
            "args": [
              {
                "name": "dest",
                "type": "LookupSource"
              },
              {
                "name": "value",
                "type": "Compact<Balance>"
              }
            ],
            "docs": [
              " Transfer some liquid free balance to another account.",
              "",
              " `transfer` will set the `FreeBalance` of the sender and receiver.",
              " It will decrease the total issuance of the system by the `TransferFee`.",
              " If the sender's account is below the existential deposit as a result",
              " of the transfer, the account will be reaped.",
              "",
              " The dispatch origin for this call must be `Signed` by the transactor.",
              "",
              " # <weight>",
              " - Dependent on arguments but not critical, given proper implementations for",
              "   input config types. See related functions below.",
              " - It contains a limited number of reads and writes internally and no complex computation.",
              "",
              " Related functions:",
              "",
              "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
              "   - Transferring balances to accounts that did not exist before will cause",
              "      `T::OnNewAccount::on_new_account` to be called.",
              "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
              "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
              "     check that the transfer will not kill the origin account.",
              " ---------------------------------",
              " - Base Weight: 73.64 Âµs, worst case scenario (account created, account removed)",
              " - DB Weight: 1 Read and 1 Write to destination account",
              " - Origin account is already in memory, so no DB operations for them.",
              " # </weight>"
            ]
          },
          {
            "name": "set_balance",
            "args": [
              {
                "name": "who",
                "type": "LookupSource"
              },
              {
                "name": "new_free",
                "type": "Compact<Balance>"
              },
              {
                "name": "new_reserved",
                "type": "Compact<Balance>"
              }
            ],
            "docs": [
              " Set the balances of a given account.",
              "",
              " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
              " also decrease the total issuance of the system (`TotalIssuance`).",
              " If the new free or reserved balance is below the existential deposit,",
              " it will reset the account nonce (`frame_system::AccountNonce`).",
              "",
              " The dispatch origin for this call is `root`.",
              "",
              " # <weight>",
              " - Independent of the arguments.",
              " - Contains a limited number of reads and writes.",
              " ---------------------",
              " - Base Weight:",
              "     - Creating: 27.56 Âµs",
              "     - Killing: 35.11 Âµs",
              " - DB Weight: 1 Read, 1 Write to `who`",
              " # </weight>"
            ]
          },
          {
            "name": "force_transfer",
            "args": [
              {
                "name": "source",
                "type": "LookupSource"
              },
              {
                "name": "dest",
                "type": "LookupSource"
              },
              {
                "name": "value",
                "type": "Compact<Balance>"
              }
            ],
            "docs": [
              " Exactly as `transfer`, except the origin must be root and the source account may be",
              " specified.",
              " # <weight>",
              " - Same as transfer, but additional read and write because the source account is",
              "   not assumed to be in the overlay.",
              " # </weight>"
            ]
          },
          {
            "name": "transfer_keep_alive",
            "args": [
              {
                "name": "dest",
                "type": "LookupSource"
              },
              {
                "name": "value",
                "type": "Compact<Balance>"
              }
            ],
            "docs": [
              " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
              " origin account.",
              "",
              " 99% of the time you want [`transfer`] instead.",
              "",
              " [`transfer`]: struct.Pallet.html#method.transfer",
              " # <weight>",
              " - Cheaper than transfer because account cannot be killed.",
              " - Base Weight: 51.4 Âµs",
              " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
              " #</weight>"
            ]
          },
          {
            "name": "transfer_all",
            "args": [
              {
                "name": "dest",
                "type": "LookupSource"
              },
              {
                "name": "keep_alive",
                "type": "bool"
              }
            ],
            "docs": [
              " Transfer the entire transferable balance from the caller account.",
              "",
              " NOTE: This function only attempts to transfer _transferable_ balances. This means that",
              " any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be",
              " transferred by this function. To ensure that this function results in a killed account,",
              " you might need to prepare the account by removing any reference counters, storage",
              " deposits, etc...",
              "",
              " The dispatch origin of this call must be Signed.",
              "",
              " - `dest`: The recipient of the transfer.",
              " - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all",
              "   of the funds the account has, causing the sender account to be killed (false), or",
              "   transfer everything except at least the existential deposit, which will guarantee to",
              "   keep the sender account alive (true).",
              "   # <weight>",
              " - O(1). Just like transfer, but reading the user's transferable balance first.",
              "   #</weight>"
            ]
          }
        ],
        "events": [
          {
            "name": "Endowed",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " An account was created with some free balance. \\[account, free_balance\\]"
            ]
          },
          {
            "name": "DustLost",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " An account was removed whose balance was non-zero but below ExistentialDeposit,",
              " resulting in an outright loss. \\[account, balance\\]"
            ]
          },
          {
            "name": "Transfer",
            "args": [
              "AccountId",
              "AccountId",
              "Balance"
            ],
            "docs": [
              " Transfer succeeded. \\[from, to, value\\]"
            ]
          },
          {
            "name": "BalanceSet",
            "args": [
              "AccountId",
              "Balance",
              "Balance"
            ],
            "docs": [
              " A balance was set by root. \\[who, free, reserved\\]"
            ]
          },
          {
            "name": "Deposit",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"
            ]
          },
          {
            "name": "Reserved",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " Some balance was reserved (moved from free to reserved). \\[who, value\\]"
            ]
          },
          {
            "name": "Unreserved",
            "args": [
              "AccountId",
              "Balance"
            ],
            "docs": [
              " Some balance was unreserved (moved from reserved to free). \\[who, value\\]"
            ]
          },
          {
            "name": "ReserveRepatriated",
            "args": [
              "AccountId",
              "AccountId",
              "Balance",
              "BalanceStatus"
            ],
            "docs": [
              " Some balance was moved from the reserve of the first account to the second account.",
              " Final argument indicates the destination balance type.",
              " \\[from, to, balance, destination_status\\]"
            ]
          }
        ],
        "constants": [
          {
            "name": "ExistentialDeposit",
            "type": "Balance",
            "value": "0x00ca9a3b000000000000000000000000",
            "docs": [
              " The minimum amount required to keep an account open."
            ]
          }
        ],
        "errors": [
          {
            "name": "VestingBalance",
            "docs": [
              " Vesting balance too high to send value"
            ]
          },
          {
            "name": "LiquidityRestrictions",
            "docs": [
              " Account liquidity restrictions prevent withdrawal"
            ]
          },
          {
            "name": "InsufficientBalance",
            "docs": [
              " Balance too low to send value"
            ]
          },
          {
            "name": "ExistentialDeposit",
            "docs": [
              " Value too low to create account due to existential deposit"
            ]
          },
          {
            "name": "KeepAlive",
            "docs": [
              " Transfer/payment would kill account"
            ]
          },
          {
            "name": "ExistingVestingSchedule",
            "docs": [
              " A vesting schedule already exists for this account"
            ]
          },
          {
            "name": "DeadAccount",
            "docs": [
              " Beneficiary account must pre-exist"
            ]
          },
          {
            "name": "TooManyReserves",
            "docs": [
              " Number of named reserves exceed MaxReserves"
            ]
          }
        ],
        "index": "30"
      },
      {
        "name": "Assets",
        "storage": {
          "prefix": "Assets",
          "items": [
            {
              "name": "Asset",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AssetId",
                  "value": "AssetDetails",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Details of an asset."
              ]
            },
            {
              "name": "Account",
              "modifier": "Default",
              "type": {
                "DoubleMap": {
                  "hasher": "Blake2_128Concat",
                  "key1": "AssetId",
                  "key2": "AccountId",
                  "value": "AssetBalance",
                  "key2Hasher": "Blake2_128Concat"
                }
              },
              "fallback": "0x00000000000000000000",
              "docs": [
                " The number of units of assets held by any given account."
              ]
            },
            {
              "name": "Approvals",
              "modifier": "Optional",
              "type": {
                "NMap": {
                  "keyVec": [
                    "AssetId",
                    "AccountId",
                    "AccountId"
                  ],
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "value": "AssetApproval"
                }
              },
              "fallback": "0x00",
              "docs": [
                " Approved balance transfers. First balance is the amount approved for transfer. Second",
                " is the amount of `T::Currency` reserved for storing this.",
                " First key is the asset ID, second key is the owner and third key is the delegate."
              ]
            },
            {
              "name": "Metadata",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AssetId",
                  "value": "AssetMetadata",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000",
              "docs": [
                " Metadata of an asset."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "create",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "admin",
                "type": "LookupSource"
              },
              {
                "name": "min_balance",
                "type": "TAssetBalance"
              }
            ],
            "docs": [
              " Issue a new class of fungible assets from a public origin.",
              "",
              " This new asset class has no assets initially and its owner is the origin.",
              "",
              " The origin must be Signed and the sender must have sufficient funds free.",
              "",
              " Funds of sender are reserved by `AssetDeposit`.",
              "",
              " Parameters:",
              " - `id`: The identifier of the new asset. This must not be currently in use to identify",
              " an existing asset.",
              " - `admin`: The admin of this class of assets. The admin is the initial address of each",
              " member of the asset class's admin team.",
              " - `min_balance`: The minimum balance of this new asset that any single account must",
              " have. If an account's balance is reduced below this, then it collapses to zero.",
              "",
              " Emits `Created` event when successful.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "force_create",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "owner",
                "type": "LookupSource"
              },
              {
                "name": "is_sufficient",
                "type": "bool"
              },
              {
                "name": "min_balance",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Issue a new class of fungible assets from a privileged origin.",
              "",
              " This new asset class has no assets initially.",
              "",
              " The origin must conform to `ForceOrigin`.",
              "",
              " Unlike `create`, no funds are reserved.",
              "",
              " - `id`: The identifier of the new asset. This must not be currently in use to identify",
              " an existing asset.",
              " - `owner`: The owner of this class of assets. The owner has full superuser permissions",
              " over this asset, but may later change and configure the permissions using `transfer_ownership`",
              " and `set_team`.",
              " - `min_balance`: The minimum balance of this new asset that any single account must",
              " have. If an account's balance is reduced below this, then it collapses to zero.",
              "",
              " Emits `ForceCreated` event when successful.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "destroy",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "witness",
                "type": "AssetDestroyWitness"
              }
            ],
            "docs": [
              " Destroy a class of fungible assets.",
              "",
              " The origin must conform to `ForceOrigin` or must be Signed and the sender must be the",
              " owner of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to be destroyed. This must identify an existing",
              " asset.",
              "",
              " Emits `Destroyed` event when successful.",
              "",
              " NOTE: It can be helpful to first freeze an asset before destroying it so that you",
              " can provide accurate witness information and prevent users from manipulating state",
              " in a way that can make it harder to destroy.",
              "",
              " Weight: `O(c + p + a)` where:",
              " - `c = (witness.accounts - witness.sufficients)`",
              " - `s = witness.sufficients`",
              " - `a = witness.approvals`"
            ]
          },
          {
            "name": "mint",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "beneficiary",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Mint assets of a particular class.",
              "",
              " The origin must be Signed and the sender must be the Issuer of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to have some amount minted.",
              " - `beneficiary`: The account to be credited with the minted assets.",
              " - `amount`: The amount of the asset to be minted.",
              "",
              " Emits `Issued` event when successful.",
              "",
              " Weight: `O(1)`",
              " Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`."
            ]
          },
          {
            "name": "burn",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "who",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.",
              "",
              " Origin must be Signed and the sender should be the Manager of the asset `id`.",
              "",
              " Bails with `BalanceZero` if the `who` is already dead.",
              "",
              " - `id`: The identifier of the asset to have some amount burned.",
              " - `who`: The account to be debited from.",
              " - `amount`: The maximum amount by which `who`'s balance should be reduced.",
              "",
              " Emits `Burned` with the actual amount burned. If this takes the balance to below the",
              " minimum for the asset, then the amount burned is increased to take it to zero.",
              "",
              " Weight: `O(1)`",
              " Modes: Post-existence of `who`; Pre & post Zombie-status of `who`."
            ]
          },
          {
            "name": "transfer",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "target",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Move some assets from the sender account to another.",
              "",
              " Origin must be Signed.",
              "",
              " - `id`: The identifier of the asset to have some amount transferred.",
              " - `target`: The account to be credited.",
              " - `amount`: The amount by which the sender's balance of assets should be reduced and",
              " `target`'s balance increased. The amount actually transferred may be slightly greater in",
              " the case that the transfer would otherwise take the sender balance above zero but below",
              " the minimum balance. Must be greater than zero.",
              "",
              " Emits `Transferred` with the actual amount transferred. If this takes the source balance",
              " to below the minimum for the asset, then the amount transferred is increased to take it",
              " to zero.",
              "",
              " Weight: `O(1)`",
              " Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of",
              " `target`."
            ]
          },
          {
            "name": "transfer_keep_alive",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "target",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Move some assets from the sender account to another, keeping the sender account alive.",
              "",
              " Origin must be Signed.",
              "",
              " - `id`: The identifier of the asset to have some amount transferred.",
              " - `target`: The account to be credited.",
              " - `amount`: The amount by which the sender's balance of assets should be reduced and",
              " `target`'s balance increased. The amount actually transferred may be slightly greater in",
              " the case that the transfer would otherwise take the sender balance above zero but below",
              " the minimum balance. Must be greater than zero.",
              "",
              " Emits `Transferred` with the actual amount transferred. If this takes the source balance",
              " to below the minimum for the asset, then the amount transferred is increased to take it",
              " to zero.",
              "",
              " Weight: `O(1)`",
              " Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of",
              " `target`."
            ]
          },
          {
            "name": "force_transfer",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "source",
                "type": "LookupSource"
              },
              {
                "name": "dest",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Move some assets from one account to another.",
              "",
              " Origin must be Signed and the sender should be the Admin of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to have some amount transferred.",
              " - `source`: The account to be debited.",
              " - `dest`: The account to be credited.",
              " - `amount`: The amount by which the `source`'s balance of assets should be reduced and",
              " `dest`'s balance increased. The amount actually transferred may be slightly greater in",
              " the case that the transfer would otherwise take the `source` balance above zero but",
              " below the minimum balance. Must be greater than zero.",
              "",
              " Emits `Transferred` with the actual amount transferred. If this takes the source balance",
              " to below the minimum for the asset, then the amount transferred is increased to take it",
              " to zero.",
              "",
              " Weight: `O(1)`",
              " Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of",
              " `dest`."
            ]
          },
          {
            "name": "freeze",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "who",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Disallow further unprivileged transfers from an account.",
              "",
              " Origin must be Signed and the sender should be the Freezer of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to be frozen.",
              " - `who`: The account to be frozen.",
              "",
              " Emits `Frozen`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "thaw",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "who",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Allow unprivileged transfers from an account again.",
              "",
              " Origin must be Signed and the sender should be the Admin of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to be frozen.",
              " - `who`: The account to be unfrozen.",
              "",
              " Emits `Thawed`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "freeze_asset",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              }
            ],
            "docs": [
              " Disallow further unprivileged transfers for the asset class.",
              "",
              " Origin must be Signed and the sender should be the Freezer of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to be frozen.",
              "",
              " Emits `Frozen`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "thaw_asset",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              }
            ],
            "docs": [
              " Allow unprivileged transfers for the asset again.",
              "",
              " Origin must be Signed and the sender should be the Admin of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to be thawed.",
              "",
              " Emits `Thawed`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "transfer_ownership",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "owner",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Change the Owner of an asset.",
              "",
              " Origin must be Signed and the sender should be the Owner of the asset `id`.",
              "",
              " - `id`: The identifier of the asset.",
              " - `owner`: The new Owner of this asset.",
              "",
              " Emits `OwnerChanged`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "set_team",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "issuer",
                "type": "LookupSource"
              },
              {
                "name": "admin",
                "type": "LookupSource"
              },
              {
                "name": "freezer",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Change the Issuer, Admin and Freezer of an asset.",
              "",
              " Origin must be Signed and the sender should be the Owner of the asset `id`.",
              "",
              " - `id`: The identifier of the asset to be frozen.",
              " - `issuer`: The new Issuer of this asset.",
              " - `admin`: The new Admin of this asset.",
              " - `freezer`: The new Freezer of this asset.",
              "",
              " Emits `TeamChanged`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "set_metadata",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "name",
                "type": "Bytes"
              },
              {
                "name": "symbol",
                "type": "Bytes"
              },
              {
                "name": "decimals",
                "type": "u8"
              }
            ],
            "docs": [
              " Set the metadata for an asset.",
              "",
              " Origin must be Signed and the sender should be the Owner of the asset `id`.",
              "",
              " Funds of sender are reserved according to the formula:",
              " `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into",
              " account any already reserved funds.",
              "",
              " - `id`: The identifier of the asset to update.",
              " - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.",
              " - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.",
              " - `decimals`: The number of decimals this asset uses to represent one unit.",
              "",
              " Emits `MetadataSet`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "clear_metadata",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              }
            ],
            "docs": [
              " Clear the metadata for an asset.",
              "",
              " Origin must be Signed and the sender should be the Owner of the asset `id`.",
              "",
              " Any deposit is freed for the asset owner.",
              "",
              " - `id`: The identifier of the asset to clear.",
              "",
              " Emits `MetadataCleared`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "force_set_metadata",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "name",
                "type": "Bytes"
              },
              {
                "name": "symbol",
                "type": "Bytes"
              },
              {
                "name": "decimals",
                "type": "u8"
              },
              {
                "name": "is_frozen",
                "type": "bool"
              }
            ],
            "docs": [
              " Force the metadata for an asset to some value.",
              "",
              " Origin must be ForceOrigin.",
              "",
              " Any deposit is left alone.",
              "",
              " - `id`: The identifier of the asset to update.",
              " - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.",
              " - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.",
              " - `decimals`: The number of decimals this asset uses to represent one unit.",
              "",
              " Emits `MetadataSet`.",
              "",
              " Weight: `O(N + S)` where N and S are the length of the name and symbol respectively."
            ]
          },
          {
            "name": "force_clear_metadata",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              }
            ],
            "docs": [
              " Clear the metadata for an asset.",
              "",
              " Origin must be ForceOrigin.",
              "",
              " Any deposit is returned.",
              "",
              " - `id`: The identifier of the asset to clear.",
              "",
              " Emits `MetadataCleared`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "force_asset_status",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "owner",
                "type": "LookupSource"
              },
              {
                "name": "issuer",
                "type": "LookupSource"
              },
              {
                "name": "admin",
                "type": "LookupSource"
              },
              {
                "name": "freezer",
                "type": "LookupSource"
              },
              {
                "name": "min_balance",
                "type": "Compact<TAssetBalance>"
              },
              {
                "name": "is_sufficient",
                "type": "bool"
              },
              {
                "name": "is_frozen",
                "type": "bool"
              }
            ],
            "docs": [
              " Alter the attributes of a given asset.",
              "",
              " Origin must be `ForceOrigin`.",
              "",
              " - `id`: The identifier of the asset.",
              " - `owner`: The new Owner of this asset.",
              " - `issuer`: The new Issuer of this asset.",
              " - `admin`: The new Admin of this asset.",
              " - `freezer`: The new Freezer of this asset.",
              " - `min_balance`: The minimum balance of this new asset that any single account must",
              " have. If an account's balance is reduced below this, then it collapses to zero.",
              " - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient",
              " value to account for the state bloat associated with its balance storage. If set to",
              " `true`, then non-zero balances may be stored without a `consumer` reference (and thus",
              " an ED in the Balances pallet or whatever else is used to control user-account state",
              " growth).",
              " - `is_frozen`: Whether this asset class is frozen except for permissioned/admin",
              " instructions.",
              "",
              " Emits `AssetStatusChanged` with the identity of the asset.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "approve_transfer",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "delegate",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Approve an amount of asset for transfer by a delegated third-party account.",
              "",
              " Origin must be Signed.",
              "",
              " Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account",
              " for the purpose of holding the approval. If some non-zero amount of assets is already",
              " approved from signing account to `delegate`, then it is topped up or unreserved to",
              " meet the right value.",
              "",
              " NOTE: The signing account does not need to own `amount` of assets at the point of",
              " making this call.",
              "",
              " - `id`: The identifier of the asset.",
              " - `delegate`: The account to delegate permission to transfer asset.",
              " - `amount`: The amount of asset that may be transferred by `delegate`. If there is",
              " already an approval in place, then this acts additively.",
              "",
              " Emits `ApprovedTransfer` on success.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "cancel_approval",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "delegate",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Cancel all of some asset approved for delegated transfer by a third-party account.",
              "",
              " Origin must be Signed and there must be an approval in place between signer and",
              " `delegate`.",
              "",
              " Unreserves any deposit previously reserved by `approve_transfer` for the approval.",
              "",
              " - `id`: The identifier of the asset.",
              " - `delegate`: The account delegated permission to transfer asset.",
              "",
              " Emits `ApprovalCancelled` on success.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "force_cancel_approval",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "owner",
                "type": "LookupSource"
              },
              {
                "name": "delegate",
                "type": "LookupSource"
              }
            ],
            "docs": [
              " Cancel all of some asset approved for delegated transfer by a third-party account.",
              "",
              " Origin must be either ForceOrigin or Signed origin with the signer being the Admin",
              " account of the asset `id`.",
              "",
              " Unreserves any deposit previously reserved by `approve_transfer` for the approval.",
              "",
              " - `id`: The identifier of the asset.",
              " - `delegate`: The account delegated permission to transfer asset.",
              "",
              " Emits `ApprovalCancelled` on success.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "name": "transfer_approved",
            "args": [
              {
                "name": "id",
                "type": "Compact<AssetId>"
              },
              {
                "name": "owner",
                "type": "LookupSource"
              },
              {
                "name": "destination",
                "type": "LookupSource"
              },
              {
                "name": "amount",
                "type": "Compact<TAssetBalance>"
              }
            ],
            "docs": [
              " Transfer some asset balance from a previously delegated account to some third-party",
              " account.",
              "",
              " Origin must be Signed and there must be an approval in place by the `owner` to the",
              " signer.",
              "",
              " If the entire amount approved for transfer is transferred, then any deposit previously",
              " reserved by `approve_transfer` is unreserved.",
              "",
              " - `id`: The identifier of the asset.",
              " - `owner`: The account which previously approved for a transfer of at least `amount` and",
              " from which the asset balance will be withdrawn.",
              " - `destination`: The account to which the asset balance of `amount` will be transferred.",
              " - `amount`: The amount of assets to transfer.",
              "",
              " Emits `TransferredApproved` on success.",
              "",
              " Weight: `O(1)`"
            ]
          }
        ],
        "events": [
          {
            "name": "Created",
            "args": [
              "AssetId",
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " Some asset class was created. \\[asset_id, creator, owner\\]"
            ]
          },
          {
            "name": "Issued",
            "args": [
              "AssetId",
              "AccountId",
              "TAssetBalance"
            ],
            "docs": [
              " Some assets were issued. \\[asset_id, owner, total_supply\\]"
            ]
          },
          {
            "name": "Transferred",
            "args": [
              "AssetId",
              "AccountId",
              "AccountId",
              "TAssetBalance"
            ],
            "docs": [
              " Some assets were transferred. \\[asset_id, from, to, amount\\]"
            ]
          },
          {
            "name": "Burned",
            "args": [
              "AssetId",
              "AccountId",
              "TAssetBalance"
            ],
            "docs": [
              " Some assets were destroyed. \\[asset_id, owner, balance\\]"
            ]
          },
          {
            "name": "TeamChanged",
            "args": [
              "AssetId",
              "AccountId",
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " The management team changed \\[asset_id, issuer, admin, freezer\\]"
            ]
          },
          {
            "name": "OwnerChanged",
            "args": [
              "AssetId",
              "AccountId"
            ],
            "docs": [
              " The owner changed \\[asset_id, owner\\]"
            ]
          },
          {
            "name": "Frozen",
            "args": [
              "AssetId",
              "AccountId"
            ],
            "docs": [
              " Some account `who` was frozen. \\[asset_id, who\\]"
            ]
          },
          {
            "name": "Thawed",
            "args": [
              "AssetId",
              "AccountId"
            ],
            "docs": [
              " Some account `who` was thawed. \\[asset_id, who\\]"
            ]
          },
          {
            "name": "AssetFrozen",
            "args": [
              "AssetId"
            ],
            "docs": [
              " Some asset `asset_id` was frozen. \\[asset_id\\]"
            ]
          },
          {
            "name": "AssetThawed",
            "args": [
              "AssetId"
            ],
            "docs": [
              " Some asset `asset_id` was thawed. \\[asset_id\\]"
            ]
          },
          {
            "name": "Destroyed",
            "args": [
              "AssetId"
            ],
            "docs": [
              " An asset class was destroyed."
            ]
          },
          {
            "name": "ForceCreated",
            "args": [
              "AssetId",
              "AccountId"
            ],
            "docs": [
              " Some asset class was force-created. \\[asset_id, owner\\]"
            ]
          },
          {
            "name": "MetadataSet",
            "args": [
              "AssetId",
              "Bytes",
              "Bytes",
              "u8",
              "bool"
            ],
            "docs": [
              " New metadata has been set for an asset. \\[asset_id, name, symbol, decimals, is_frozen\\]"
            ]
          },
          {
            "name": "MetadataCleared",
            "args": [
              "AssetId"
            ],
            "docs": [
              " Metadata has been cleared for an asset. \\[asset_id\\]"
            ]
          },
          {
            "name": "ApprovedTransfer",
            "args": [
              "AssetId",
              "AccountId",
              "AccountId",
              "TAssetBalance"
            ],
            "docs": [
              " (Additional) funds have been approved for transfer to a destination account.",
              " \\[asset_id, source, delegate, amount\\]"
            ]
          },
          {
            "name": "ApprovalCancelled",
            "args": [
              "AssetId",
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " An approval for account `delegate` was cancelled by `owner`.",
              " \\[id, owner, delegate\\]"
            ]
          },
          {
            "name": "TransferredApproved",
            "args": [
              "AssetId",
              "AccountId",
              "AccountId",
              "AccountId",
              "TAssetBalance"
            ],
            "docs": [
              " An `amount` was transferred in its entirety from `owner` to `destination` by",
              " the approved `delegate`.",
              " \\[id, owner, delegate, destination\\]"
            ]
          },
          {
            "name": "AssetStatusChanged",
            "args": [
              "AssetId"
            ],
            "docs": [
              " An asset has had its attributes changed by the `Force` origin.",
              " \\[id\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "BalanceLow",
            "docs": [
              " Account balance must be greater than or equal to the transfer amount."
            ]
          },
          {
            "name": "BalanceZero",
            "docs": [
              " Balance should be non-zero."
            ]
          },
          {
            "name": "NoPermission",
            "docs": [
              " The signing account has no permission to do the operation."
            ]
          },
          {
            "name": "Unknown",
            "docs": [
              " The given asset ID is unknown."
            ]
          },
          {
            "name": "Frozen",
            "docs": [
              " The origin account is frozen."
            ]
          },
          {
            "name": "InUse",
            "docs": [
              " The asset ID is already taken."
            ]
          },
          {
            "name": "BadWitness",
            "docs": [
              " Invalid witness data given."
            ]
          },
          {
            "name": "MinBalanceZero",
            "docs": [
              " Minimum balance should be non-zero."
            ]
          },
          {
            "name": "NoProvider",
            "docs": [
              " No provider reference exists to allow a non-zero balance of a non-self-sufficient asset."
            ]
          },
          {
            "name": "BadMetadata",
            "docs": [
              " Invalid metadata given."
            ]
          },
          {
            "name": "Unapproved",
            "docs": [
              " No approval exists that would allow the transfer."
            ]
          },
          {
            "name": "WouldDie",
            "docs": [
              " The source account would not survive the transfer and it needs to stay alive."
            ]
          }
        ],
        "index": "31"
      },
      {
        "name": "Aura",
        "storage": null,
        "calls": null,
        "events": null,
        "constants": [],
        "errors": [],
        "index": "32"
      },
      {
        "name": "AuraExt",
        "storage": null,
        "calls": null,
        "events": null,
        "constants": [],
        "errors": [],
        "index": "33"
      },
      {
        "name": "XcmpQueue",
        "storage": {
          "prefix": "XcmpQueue",
          "items": [
            {
              "name": "InboundXcmpStatus",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<(ParaId,InboundStatus,Vec<(RelayBlockNumber,XcmpMessageFormat)>)>"
              },
              "fallback": "0x00",
              "docs": [
                " Status of the inbound XCMP channels."
              ]
            },
            {
              "name": "InboundXcmpMessages",
              "modifier": "Default",
              "type": {
                "DoubleMap": {
                  "hasher": "Blake2_128Concat",
                  "key1": "ParaId",
                  "key2": "RelayBlockNumber",
                  "value": "Bytes",
                  "key2Hasher": "Twox64Concat"
                }
              },
              "fallback": "0x00",
              "docs": [
                " Inbound aggregate XCMP messages. It can only be one per ParaId/block."
              ]
            },
            {
              "name": "OutboundXcmpStatus",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<(ParaId,OutboundStatus,bool,u16,u16)>"
              },
              "fallback": "0x00",
              "docs": [
                " The non-empty XCMP channels in order of becoming non-empty, and the index of the first",
                " and last outbound message. If the two indices are equal, then it indicates an empty",
                " queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater",
                " than 65535 items. Queue indices for normal messages begin at one; zero is reserved in",
                " case of the need to send a high-priority signal message this block.",
                " The bool is true if there is a signal message waiting to be sent."
              ]
            },
            {
              "name": "OutboundXcmpMessages",
              "modifier": "Default",
              "type": {
                "DoubleMap": {
                  "hasher": "Blake2_128Concat",
                  "key1": "ParaId",
                  "key2": "u16",
                  "value": "Bytes",
                  "key2Hasher": "Twox64Concat"
                }
              },
              "fallback": "0x00",
              "docs": [
                " The messages outbound in a given XCMP channel."
              ]
            },
            {
              "name": "SignalMessages",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "ParaId",
                  "value": "Bytes",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Any signal messages waiting to be sent."
              ]
            },
            {
              "name": "QueueConfig",
              "modifier": "Default",
              "type": {
                "Plain": "QueueConfigData"
              },
              "fallback": "0x020000000500000001000000a0860100000000000200000000000000",
              "docs": [
                " The configuration which controls the dynamics of the outbound queue."
              ]
            }
          ]
        },
        "calls": [],
        "events": [
          {
            "name": "Success",
            "args": [
              "Option<Hash>"
            ],
            "docs": [
              " Some XCM was executed ok."
            ]
          },
          {
            "name": "Fail",
            "args": [
              "Option<Hash>",
              "XcmError"
            ],
            "docs": [
              " Some XCM failed."
            ]
          },
          {
            "name": "BadVersion",
            "args": [
              "Option<Hash>"
            ],
            "docs": [
              " Bad XCM version used."
            ]
          },
          {
            "name": "BadFormat",
            "args": [
              "Option<Hash>"
            ],
            "docs": [
              " Bad XCM format used."
            ]
          },
          {
            "name": "UpwardMessageSent",
            "args": [
              "Option<Hash>"
            ],
            "docs": [
              " An upward message was sent to the relay chain."
            ]
          },
          {
            "name": "XcmpMessageSent",
            "args": [
              "Option<Hash>"
            ],
            "docs": [
              " An HRMP message was sent to a sibling parachain."
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "FailedToSend",
            "docs": [
              " Failed to send XCM message."
            ]
          },
          {
            "name": "BadXcmOrigin",
            "docs": [
              " Bad XCM origin."
            ]
          },
          {
            "name": "BadXcm",
            "docs": [
              " Bad XCM data."
            ]
          }
        ],
        "index": "50"
      },
      {
        "name": "PolkadotXcm",
        "storage": null,
        "calls": [
          {
            "name": "send",
            "args": [
              {
                "name": "dest",
                "type": "MultiLocation"
              },
              {
                "name": "message",
                "type": "Xcm"
              }
            ],
            "docs": []
          },
          {
            "name": "teleport_assets",
            "args": [
              {
                "name": "dest",
                "type": "MultiLocation"
              },
              {
                "name": "beneficiary",
                "type": "MultiLocation"
              },
              {
                "name": "assets",
                "type": "Vec<MultiAsset>"
              },
              {
                "name": "dest_weight",
                "type": "Weight"
              }
            ],
            "docs": [
              " Teleport some assets from the local chain to some destination chain.",
              "",
              " - `origin`: Must be capable of withdrawing the `assets` and executing XCM.",
              " - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send",
              "   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.",
              " - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be",
              "   an `AccountId32` value.",
              " - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the",
              "   `dest` side.",
              " - `dest_weight`: Equal to the total weight on `dest` of the XCM message",
              "   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`."
            ]
          },
          {
            "name": "reserve_transfer_assets",
            "args": [
              {
                "name": "dest",
                "type": "MultiLocation"
              },
              {
                "name": "beneficiary",
                "type": "MultiLocation"
              },
              {
                "name": "assets",
                "type": "Vec<MultiAsset>"
              },
              {
                "name": "dest_weight",
                "type": "Weight"
              }
            ],
            "docs": [
              " Transfer some assets from the local chain to the sovereign account of a destination chain and forward",
              " a notification XCM.",
              "",
              " - `origin`: Must be capable of withdrawing the `assets` and executing XCM.",
              " - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send",
              "   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.",
              " - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be",
              "   an `AccountId32` value.",
              " - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the",
              "   `dest` side.",
              " - `dest_weight`: Equal to the total weight on `dest` of the XCM message",
              "   `ReserveAssetDeposit { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`."
            ]
          },
          {
            "name": "execute",
            "args": [
              {
                "name": "message",
                "type": "Xcm"
              },
              {
                "name": "max_weight",
                "type": "Weight"
              }
            ],
            "docs": [
              " Execute an XCM message from a local, signed, origin.",
              "",
              " An event is deposited indicating whether `msg` could be executed completely or only",
              " partially.",
              "",
              " No more than `max_weight` will be used in its attempted execution. If this is less than the",
              " maximum amount of weight that the message could take to be executed, then no execution",
              " attempt will be made.",
              "",
              " NOTE: A successful return to this does *not* imply that the `msg` was executed successfully",
              " to completion; only that *some* of it was executed."
            ]
          }
        ],
        "events": [
          {
            "name": "Attempted",
            "args": [
              "Outcome"
            ],
            "docs": []
          },
          {
            "name": "Sent",
            "args": [
              "MultiLocation",
              "MultiLocation",
              "Xcm"
            ],
            "docs": []
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "Unreachable",
            "docs": []
          },
          {
            "name": "SendFailure",
            "docs": []
          },
          {
            "name": "Filtered",
            "docs": [
              " The message execution fails the filter."
            ]
          },
          {
            "name": "UnweighableMessage",
            "docs": [
              " The message's weight could not be determined."
            ]
          }
        ],
        "index": "51"
      },
      {
        "name": "CumulusXcm",
        "storage": null,
        "calls": [],
        "events": [
          {
            "name": "InvalidFormat",
            "args": [
              "[u8;8]"
            ],
            "docs": [
              " Downward message is invalid XCM.",
              " \\[ id \\]"
            ]
          },
          {
            "name": "UnsupportedVersion",
            "args": [
              "[u8;8]"
            ],
            "docs": [
              " Downward message is unsupported version of XCM.",
              " \\[ id \\]"
            ]
          },
          {
            "name": "ExecutedDownward",
            "args": [
              "[u8;8]",
              "Outcome"
            ],
            "docs": [
              " Downward message executed with the given outcome.",
              " \\[ id, outcome \\]"
            ]
          }
        ],
        "constants": [],
        "errors": [],
        "index": "52"
      },
      {
        "name": "DmpQueue",
        "storage": {
          "prefix": "DmpQueue",
          "items": [
            {
              "name": "Configuration",
              "modifier": "Default",
              "type": {
                "Plain": "ConfigData"
              },
              "fallback": "0x00e40b5402000000",
              "docs": [
                " The configuration."
              ]
            },
            {
              "name": "PageIndex",
              "modifier": "Default",
              "type": {
                "Plain": "PageIndexData"
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The page index."
              ]
            },
            {
              "name": "Pages",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "PageCounter",
                  "value": "Vec<(RelayBlockNumber,Bytes)>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " The queue pages."
              ]
            },
            {
              "name": "Overweight",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "OverweightIndex",
                  "value": "(RelayBlockNumber,Bytes)",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " The overweight messages."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "service_overweight",
            "args": [
              {
                "name": "index",
                "type": "OverweightIndex"
              },
              {
                "name": "weight_limit",
                "type": "Weight"
              }
            ],
            "docs": [
              " Service a single overweight message.",
              "",
              " - `origin`: Must pass `ExecuteOverweightOrigin`.",
              " - `index`: The index of the overweight message to service.",
              " - `weight_limit`: The amount of weight that message execution may take.",
              "",
              " Errors:",
              " - `Unknown`: Message of `index` is unknown.",
              " - `OverLimit`: Message execution may use greater than `weight_limit`.",
              "",
              " Events:",
              " - `OverweightServiced`: On success."
            ]
          }
        ],
        "events": [
          {
            "name": "InvalidFormat",
            "args": [
              "MessageId"
            ],
            "docs": [
              " Downward message is invalid XCM.",
              " \\[ id \\]"
            ]
          },
          {
            "name": "UnsupportedVersion",
            "args": [
              "MessageId"
            ],
            "docs": [
              " Downward message is unsupported version of XCM.",
              " \\[ id \\]"
            ]
          },
          {
            "name": "ExecutedDownward",
            "args": [
              "MessageId",
              "Outcome"
            ],
            "docs": [
              " Downward message executed with the given outcome.",
              " \\[ id, outcome \\]"
            ]
          },
          {
            "name": "WeightExhausted",
            "args": [
              "MessageId",
              "Weight",
              "Weight"
            ],
            "docs": [
              " The weight limit for handling downward messages was reached.",
              " \\[ id, remaining, required \\]"
            ]
          },
          {
            "name": "OverweightEnqueued",
            "args": [
              "MessageId",
              "OverweightIndex",
              "Weight"
            ],
            "docs": [
              " Downward message is overweight and was placed in the overweight queue.",
              " \\[ id, index, required \\]"
            ]
          },
          {
            "name": "OverweightServiced",
            "args": [
              "OverweightIndex",
              "Weight"
            ],
            "docs": [
              " Downward message from the overweight queue was executed.",
              " \\[ index, used \\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "Unknown",
            "docs": [
              " The message index given is unknown."
            ]
          },
          {
            "name": "OverLimit",
            "docs": [
              " The amount of weight given is possibly not enough for executing the message."
            ]
          }
        ],
        "index": "53"
      },
      {
        "name": "Spambot",
        "storage": {
          "prefix": "Spambot",
          "items": [
            {
              "name": "Targets",
              "modifier": "Default",
              "type": {
                "Plain": "Vec<(ParaId,Bytes)>"
              },
              "fallback": "0x00",
              "docs": [
                " The target parachains to ping."
              ]
            },
            {
              "name": "PingCount",
              "modifier": "Default",
              "type": {
                "Plain": "u32"
              },
              "fallback": "0x00000000",
              "docs": [
                " The total number of pings sent."
              ]
            },
            {
              "name": "Pings",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "u32",
                  "value": "BlockNumber",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " The sent pings."
              ]
            }
          ]
        },
        "calls": [
          {
            "name": "start",
            "args": [
              {
                "name": "para",
                "type": "ParaId"
              },
              {
                "name": "payload",
                "type": "Bytes"
              }
            ],
            "docs": []
          },
          {
            "name": "start_many",
            "args": [
              {
                "name": "para",
                "type": "ParaId"
              },
              {
                "name": "count",
                "type": "u32"
              },
              {
                "name": "payload",
                "type": "Bytes"
              }
            ],
            "docs": []
          },
          {
            "name": "stop",
            "args": [
              {
                "name": "para",
                "type": "ParaId"
              }
            ],
            "docs": []
          },
          {
            "name": "stop_all",
            "args": [
              {
                "name": "maybe_para",
                "type": "Option<ParaId>"
              }
            ],
            "docs": []
          },
          {
            "name": "ping",
            "args": [
              {
                "name": "seq",
                "type": "u32"
              },
              {
                "name": "payload",
                "type": "Bytes"
              }
            ],
            "docs": []
          },
          {
            "name": "pong",
            "args": [
              {
                "name": "seq",
                "type": "u32"
              },
              {
                "name": "payload",
                "type": "Bytes"
              }
            ],
            "docs": []
          }
        ],
        "events": [
          {
            "name": "PingSent",
            "args": [
              "ParaId",
              "u32",
              "Bytes"
            ],
            "docs": []
          },
          {
            "name": "Pinged",
            "args": [
              "ParaId",
              "u32",
              "Bytes"
            ],
            "docs": []
          },
          {
            "name": "PongSent",
            "args": [
              "ParaId",
              "u32",
              "Bytes"
            ],
            "docs": []
          },
          {
            "name": "Ponged",
            "args": [
              "ParaId",
              "u32",
              "Bytes",
              "BlockNumber"
            ],
            "docs": []
          },
          {
            "name": "ErrorSendingPing",
            "args": [
              "XcmError",
              "ParaId",
              "u32",
              "Bytes"
            ],
            "docs": []
          },
          {
            "name": "ErrorSendingPong",
            "args": [
              "XcmError",
              "ParaId",
              "u32",
              "Bytes"
            ],
            "docs": []
          },
          {
            "name": "UnknownPong",
            "args": [
              "ParaId",
              "u32",
              "Bytes"
            ],
            "docs": []
          }
        ],
        "constants": [],
        "errors": [],
        "index": "99"
      },
      {
        "name": "OrmlNFT",
        "storage": {
          "prefix": "OrmlNFT",
          "items": [
            {
              "name": "NextClassId",
              "modifier": "Default",
              "type": {
                "Plain": "ClassId"
              },
              "fallback": "0x00000000",
              "docs": [
                " Next available class ID."
              ]
            },
            {
              "name": "NextTokenId",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "ClassId",
                  "value": "TokenId",
                  "linked": false
                }
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " Next available token ID."
              ]
            },
            {
              "name": "Classes",
              "modifier": "Optional",
              "type": {
                "Map": {
                  "hasher": "Twox64Concat",
                  "key": "ClassId",
                  "value": "ClassInfoOf",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": [
                " Store class info.",
                "",
                " Returns `None` if class info not set or removed."
              ]
            },
            {
              "name": "Tokens",
              "modifier": "Optional",
              "type": {
                "DoubleMap": {
                  "hasher": "Twox64Concat",
                  "key1": "ClassId",
                  "key2": "TokenId",
                  "value": "TokenInfoOf",
                  "key2Hasher": "Twox64Concat"
                }
              },
              "fallback": "0x00",
              "docs": [
                " Store token info.",
                "",
                " Returns `None` if token info not set or removed."
              ]
            },
            {
              "name": "TokensByOwner",
              "modifier": "Default",
              "type": {
                "DoubleMap": {
                  "hasher": "Twox64Concat",
                  "key1": "AccountId",
                  "key2": "(ClassId,TokenId)",
                  "value": "()",
                  "key2Hasher": "Twox64Concat"
                }
              },
              "fallback": "",
              "docs": [
                " Token existence check by owner and class ID."
              ]
            }
          ]
        },
        "calls": null,
        "events": null,
        "constants": [],
        "errors": [
          {
            "name": "NoAvailableClassId",
            "docs": [
              " No available class ID"
            ]
          },
          {
            "name": "NoAvailableTokenId",
            "docs": [
              " No available token ID"
            ]
          },
          {
            "name": "TokenNotFound",
            "docs": [
              " Token(ClassId, TokenId) not found"
            ]
          },
          {
            "name": "ClassNotFound",
            "docs": [
              " Class not found"
            ]
          },
          {
            "name": "NoPermission",
            "docs": [
              " The operator is not the owner of the token and has no permission"
            ]
          },
          {
            "name": "CannotDestroyClass",
            "docs": [
              " Can not destroy class",
              " Total issuance is not 0"
            ]
          },
          {
            "name": "MaxMetadataExceeded",
            "docs": [
              " Failed because the Maximum amount of metadata was exceeded"
            ]
          }
        ],
        "index": "100"
      },
      {
        "name": "AccountLinkerModule",
        "storage": {
          "prefix": "AccountLinkerModule",
          "items": [
            {
              "name": "EthereumLink",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Vec<EthAddress>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": []
            },
            {
              "name": "BitcoinLink",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Vec<Bytes>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": []
            },
            {
              "name": "PolkadotLink",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Vec<AccountId>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": []
            },
            {
              "name": "PolkadotPending",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "(AccountId,u32)",
                  "linked": false
                }
              },
              "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": []
            }
          ]
        },
        "calls": [
          {
            "name": "link_eth",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              },
              {
                "name": "index",
                "type": "u32"
              },
              {
                "name": "addr_expected",
                "type": "EthAddress"
              },
              {
                "name": "expiring_block_number",
                "type": "BlockNumber"
              },
              {
                "name": "sig",
                "type": "Signature"
              }
            ],
            "docs": [
              " Link an Ethereum address to a Litentry account providing a proof signature from the private key",
              " of that Ethereum address.",
              "",
              " The runtime needs to ensure that a malicious index can be handled correctly. ",
              " Currently, when vec.len > MAX_ETH_LINKS, replacement will always happen at the final index. ",
              " Otherwise it will use the next new slot unless index is valid against a currently available slot.",
              " ",
              " Parameters:",
              " - `account`: The Litentry address that is to be linked",
              " - `index`: The index of the linked Ethereum address that the user wants to replace with.",
              " - `addr_expected`: The intended Ethereum address to link to the origin's Litentry address",
              " - `expiring_block_number`: The block number after which this link request will expire",
              " - `sig`: The rsv-signature generated by the private key of the addr_expected",
              " ",
              " Emits `EthAddressLinked` event when successful."
            ]
          },
          {
            "name": "link_btc",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              },
              {
                "name": "index",
                "type": "u32"
              },
              {
                "name": "addr_expected",
                "type": "Bytes"
              },
              {
                "name": "expiring_block_number",
                "type": "BlockNumber"
              },
              {
                "name": "sig",
                "type": "Signature"
              }
            ],
            "docs": [
              " Link a BTC address to a Litentry account providing a proof signature from the private key",
              " of that BTC address. The BTC address may either be a legacy P2PK one (started with b'1')",
              " or a Segwit P2PK one (started with b'bc').",
              "",
              " The runtime needs to ensure that a malicious index can be handled correctly. ",
              " Currently, when vec.len > MAX_ETH_LINKS, replacement will always happen at the final index. ",
              " Otherwise it will use the next new slot unless index is valid against a currently available slot.",
              " ",
              " Parameters:",
              " - `account`: The Litentry address that is to be linked",
              " - `index`: The index of the linked BTC address that the user wants to replace with.",
              " - `addr_expected`: The intended BTC address to link to the origin's Litentry address",
              " - `expiring_block_number`: The block number after which this link request will expire",
              " - `sig`: The rsv-signature generated by the private key of the addr_expected",
              " ",
              " Emits `BtcAddressLinked` event when successful."
            ]
          },
          {
            "name": "link_polkadot",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              },
              {
                "name": "index",
                "type": "u32"
              }
            ],
            "docs": [
              " Initiate a link request to link a Litentry address (= any account in Polkadot ecosystem)",
              " to another Litentry address (= any account in Polkadot ecosystem).",
              " ",
              " Parameters:",
              " - `account`: The Litentry address that is to be linked",
              " - `index`: The index of the linked Litentry address that the user wants to replace with."
            ]
          },
          {
            "name": "accept_polkadot",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              }
            ],
            "docs": [
              " Accept a pending `link_polkadot` request to link a Litentry address (= any account in Polkadot ecosystem)",
              " to another Litentry address (= any account in Polkadot ecosystem).",
              "",
              " The runtime needs to ensure that a malicious index can be handled correctly. ",
              " Currently, when vec.len > MAX_ETH_LINKS, replacement will always happen at the final index. ",
              " Otherwise it will use the next new slot unless index is valid against a currently available slot.",
              " ",
              " Parameters:",
              " - `account`: The Litentry address that is to be linked",
              " ",
              " Emits `PolkadotAddressLinked` event when successful."
            ]
          }
        ],
        "events": [
          {
            "name": "EthAddressLinked",
            "args": [
              "AccountId",
              "Bytes"
            ],
            "docs": [
              " Ethereum address successfully linked. \\[Lintentry account, Ethereum account\\]"
            ]
          },
          {
            "name": "BtcAddressLinked",
            "args": [
              "AccountId",
              "Bytes"
            ],
            "docs": [
              " BTC address successfully linked. \\[Lintentry account, BTC account\\]"
            ]
          },
          {
            "name": "PolkadotAddressLinked",
            "args": [
              "AccountId",
              "AccountId"
            ],
            "docs": [
              " Polkadot address successfully linked. \\[Lintentry account, Polkadot account\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "EcdsaRecoverFailure",
            "docs": []
          },
          {
            "name": "LinkRequestExpired",
            "docs": []
          },
          {
            "name": "UnexpectedAddress",
            "docs": []
          },
          {
            "name": "UnexpectedEthMsgLength",
            "docs": []
          },
          {
            "name": "InvalidBTCAddress",
            "docs": []
          },
          {
            "name": "InvalidExpiringBlockNumber",
            "docs": []
          },
          {
            "name": "WrongPendingRequest",
            "docs": []
          }
        ],
        "index": "101"
      },
      {
        "name": "OffchainWorkerModule",
        "storage": {
          "prefix": "OffchainWorkerModule",
          "items": [
            {
              "name": "TotalClaims",
              "modifier": "Optional",
              "type": {
                "Plain": "u64"
              },
              "fallback": "0x00",
              "docs": []
            },
            {
              "name": "ClaimAccountSet",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "()",
                  "linked": false
                }
              },
              "fallback": "",
              "docs": []
            },
            {
              "name": "ClaimAccountIndex",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Option<u32>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": []
            },
            {
              "name": "AccountBalance",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "(Option<u128>,Option<u128>)",
                  "linked": false
                }
              },
              "fallback": "0x0000",
              "docs": []
            },
            {
              "name": "CommitAccountBalance",
              "modifier": "Default",
              "type": {
                "DoubleMap": {
                  "hasher": "Blake2_128Concat",
                  "key1": "AccountId",
                  "key2": "QueryKey",
                  "value": "Option<u128>",
                  "key2Hasher": "Blake2_128Concat"
                }
              },
              "fallback": "0x00",
              "docs": [
                " Record account's btc and ethereum balance"
              ]
            },
            {
              "name": "OcwAccountIndex",
              "modifier": "Default",
              "type": {
                "Map": {
                  "hasher": "Blake2_128Concat",
                  "key": "AccountId",
                  "value": "Option<u32>",
                  "linked": false
                }
              },
              "fallback": "0x00",
              "docs": []
            }
          ]
        },
        "calls": [
          {
            "name": "asset_claim",
            "args": [],
            "docs": [
              " Request the Litentry to query balances of linked Eth and BTC accounts.",
              "",
              " This will alter `ClaimAccountSet` in storage. ",
              "",
              " The dispatch origin for this call is `account`.",
              "",
              " # <weight>",
              " - Independent of the arguments.",
              " - Contains a limited number of reads and writes.",
              " ---------------------",
              " - Base Weight:",
              "     - Creating: 27.56 Âµs",
              "     - Killing: 35.11 Âµs",
              " - DB Weight: 1 Read, 1 Write",
              " # </weight>",
              " "
            ]
          },
          {
            "name": "submit_balance",
            "args": [
              {
                "name": "account",
                "type": "AccountId"
              },
              {
                "name": "block_number",
                "type": "BlockNumber"
              },
              {
                "name": "data_source",
                "type": "DataSource"
              },
              {
                "name": "balance",
                "type": "u128"
              }
            ],
            "docs": [
              " Offchain worker submit linked Eth and BTC balance via extrinsic.",
              "",
              " Extrinsic Arguments.",
              " account: the target account offchain-worker query data for. ",
              " block_number: the block number for offchain-worker trigger the query.",
              " data_source: the enum for different data source defined in urls.rs.",
              " balance: the balance returned from data source.",
              " ",
              " This will alter `CommitAccountBalance` in storage. ",
              "",
              " The dispatch origin for this call is `account`.",
              "",
              " # <weight>",
              " - Independent of the arguments.",
              " - Contains a limited number of reads and writes.",
              " ---------------------",
              " - Base Weight:",
              "     - Creating: 27.56 Âµs",
              "     - Killing: 35.11 Âµs",
              " - DB Weight: 1 Read, 1 Write",
              " # </weight>",
              " "
            ]
          }
        ],
        "events": [
          {
            "name": "BalanceGot",
            "args": [
              "AccountId",
              "BlockNumber",
              "Option<u128>",
              "Option<u128>"
            ],
            "docs": []
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "InvalidNumber",
            "docs": [
              " Error number parsing."
            ]
          },
          {
            "name": "AccountAlreadyInClaimlist",
            "docs": [
              " Account already in claim list."
            ]
          },
          {
            "name": "InvalidDataSource",
            "docs": [
              " Invalid data source"
            ]
          },
          {
            "name": "InvalidCommitBlockNumber",
            "docs": [
              " Invalid commit block number"
            ]
          },
          {
            "name": "InvalidCommitSlot",
            "docs": [
              " Invalid commit slot"
            ]
          },
          {
            "name": "InvalidAccountIndex",
            "docs": [
              " Invalid account index"
            ]
          },
          {
            "name": "OffchainWorkerIndexOverflow",
            "docs": [
              " Offchain worker index overflow"
            ]
          }
        ],
        "index": "102"
      },
      {
        "name": "NFT",
        "storage": null,
        "calls": [
          {
            "name": "create_class",
            "args": [
              {
                "name": "metadata",
                "type": "CID"
              },
              {
                "name": "properties",
                "type": "Properties"
              },
              {
                "name": "start_block",
                "type": "Option<BlockNumberOf>"
              },
              {
                "name": "end_block",
                "type": "Option<BlockNumberOf>"
              },
              {
                "name": "class_type",
                "type": "ClassType"
              }
            ],
            "docs": [
              " Create NFT class, each class is a collection of NFT instances.",
              " Currently there are 3 types (refer to `ClassType`)",
              " 1. Each instance is directly issued by the corresponding third party: Simple(u32)",
              " 2. At issuance, a list of user is provided and only these users may claim: Claim(HashByte32)",
              " 3. Can be minted only when the user have 2 specific base non fungible assets: Merge(ID, ID, bool)",
              " ",
              " Parameters:",
              " - `metadata`: CID identifier of the class's metadata",
              " - `properties`: Class property, include `Transferable` `Burnable`",
              " - `start_block`: From when the instances can be minted (None if no restriction)",
              " - `end_block`: Till when the instances can be minted (None if no restriction)",
              " - `class_type`: Type of this class (refer to `ClassType`)",
              " ",
              " Emits `CreatedClass` event when successful."
            ]
          },
          {
            "name": "mint",
            "args": [
              {
                "name": "to",
                "type": "LookupSource"
              },
              {
                "name": "class_id",
                "type": "ClassIdOf"
              },
              {
                "name": "metadata",
                "type": "CID"
              },
              {
                "name": "quantity",
                "type": "u32"
              }
            ],
            "docs": [
              " Mint `Simple(u32)` NFT instances from the class owner",
              " ",
              " Parameters:",
              " - `to`: The receiver of the minted NFTs",
              " - `class_id`: Identifier of the NFT class to mint",
              " - `metadata`: CID identifier of the instance's metadata",
              " - `quantity`: number of NFT to mint",
              " ",
              " Emits `MintedToken` event when successful"
            ]
          },
          {
            "name": "claim",
            "args": [
              {
                "name": "index",
                "type": "u16"
              },
              {
                "name": "class_id",
                "type": "ClassIdOf"
              },
              {
                "name": "proof",
                "type": "Vec<HashByte32>"
              }
            ],
            "docs": [
              " Claim a `Claim(HashByte32)` by a whitelisted user,",
              " with a Merkle proof that proves the user's account",
              " is in the Merkle tree of the given root",
              " ",
              " Parameters:",
              " - `index`: Index of user's Merkle proof",
              " - `class_id`: Identifier of the NFT class to mint",
              " - `proof`: Merkle proof",
              " ",
              " Emits `ClaimedToken` event when successful"
            ]
          },
          {
            "name": "merge",
            "args": [
              {
                "name": "class_id",
                "type": "ClassIdOf"
              },
              {
                "name": "token1",
                "type": "(ClassIdOf,TokenIdOf)"
              },
              {
                "name": "token2",
                "type": "(ClassIdOf,TokenIdOf)"
              }
            ],
            "docs": [
              " Merge from two NFT instances and generate a new NFT",
              " of type `Merge(ID, ID, bool)`",
              " ",
              " Parameters:",
              " - `class_id`: Identifier of the NFT class to mint",
              " - `token1`: First NFT of the merge base",
              " - `token2`: Seconde NFT of the merge base",
              " ",
              " Emits `MergedToken` event when successful"
            ]
          },
          {
            "name": "transfer",
            "args": [
              {
                "name": "to",
                "type": "LookupSource"
              },
              {
                "name": "token",
                "type": "(ClassIdOf,TokenIdOf)"
              }
            ],
            "docs": [
              " Transfer NFT token to another account, must be transferable",
              "",
              " Parameters:",
              " - `to`: Receiver of the token",
              " - `token`: NFT instance to transfer",
              " ",
              " Emits `TransferredToken` event when successful"
            ]
          },
          {
            "name": "burn",
            "args": [
              {
                "name": "token",
                "type": "(ClassIdOf,TokenIdOf)"
              }
            ],
            "docs": [
              " Burn an NFT token instance, must be burnable",
              "",
              " Parameters:",
              " - `token`: NFT instance to burn",
              " ",
              " Emits `BurnedToken` event when successful"
            ]
          }
        ],
        "events": [
          {
            "name": "CreatedClass",
            "args": [
              "AccountId",
              "ClassIdOf"
            ],
            "docs": [
              " Created NFT class. \\[owner, class_id\\]"
            ]
          },
          {
            "name": "MintedToken",
            "args": [
              "AccountId",
              "AccountId",
              "ClassIdOf",
              "u32"
            ],
            "docs": [
              " Minted NFT token. \\[from, to, class_id, quantity\\]"
            ]
          },
          {
            "name": "ClaimedToken",
            "args": [
              "AccountId",
              "ClassIdOf"
            ],
            "docs": [
              " Claimed NFT token. \\[claimer, class_id\\]"
            ]
          },
          {
            "name": "MergedToken",
            "args": [
              "AccountId",
              "ClassIdOf"
            ],
            "docs": [
              " Merged NFT token. \\[owner, class_id\\]"
            ]
          },
          {
            "name": "TransferredToken",
            "args": [
              "AccountId",
              "AccountId",
              "ClassIdOf",
              "TokenIdOf"
            ],
            "docs": [
              " Transferred NFT token. \\[from, to, class_id, token_id\\]"
            ]
          },
          {
            "name": "BurnedToken",
            "args": [
              "AccountId",
              "ClassIdOf",
              "TokenIdOf"
            ],
            "docs": [
              " Burned NFT token. \\[owner, class_id, token_id\\]"
            ]
          },
          {
            "name": "BurnedTokenWithRemark",
            "args": [
              "AccountId",
              "ClassIdOf",
              "TokenIdOf",
              "Hash"
            ],
            "docs": [
              " Burned NFT token with remark. \\[owner, class_id, token_id, remark_hash\\]"
            ]
          },
          {
            "name": "DestroyedClass",
            "args": [
              "AccountId",
              "ClassIdOf"
            ],
            "docs": [
              " Destroyed NFT class. \\[owner, class_id\\]"
            ]
          }
        ],
        "constants": [],
        "errors": [
          {
            "name": "ClassIdNotFound",
            "docs": [
              " ClassId not found"
            ]
          },
          {
            "name": "ClassClaimedListNotFound",
            "docs": [
              " Class ClaimedList not found (Only for Claim type)"
            ]
          },
          {
            "name": "TokenIdNotFound",
            "docs": [
              " TokenId not found"
            ]
          },
          {
            "name": "NoPermission",
            "docs": [
              " The operator is not the owner of the token and has no permission"
            ]
          },
          {
            "name": "InvalidQuantity",
            "docs": [
              " Quantity is invalid. need >= 1"
            ]
          },
          {
            "name": "NonTransferable",
            "docs": [
              " Property of class don't support transfer"
            ]
          },
          {
            "name": "NonBurnable",
            "docs": [
              " Property of class don't support burn"
            ]
          },
          {
            "name": "TokenNotFound",
            "docs": [
              " Token not found"
            ]
          },
          {
            "name": "WrongClassType",
            "docs": [
              " Wrong class type"
            ]
          },
          {
            "name": "WrongMergeBase",
            "docs": [
              " Merge nft's base nfts are not provided correctly"
            ]
          },
          {
            "name": "TokenUsed",
            "docs": [
              " Use already used token to merge new token"
            ]
          },
          {
            "name": "QuantityOverflow",
            "docs": [
              " Mint more NFT than the maximum allowed"
            ]
          },
          {
            "name": "OutOfCampaignPeriod",
            "docs": [
              " Out of NFT valid issuance period"
            ]
          },
          {
            "name": "TokenAlreadyClaimed",
            "docs": [
              " NFT for certain user already claimed"
            ]
          },
          {
            "name": "UserNotInClaimList",
            "docs": [
              " user claim verification fails"
            ]
          }
        ],
        "index": "103"
      }
    ],
    "extrinsic": {
      "version": "4",
      "signedExtensions": [
        "CheckSpecVersion",
        "CheckGenesis",
        "CheckMortality",
        "CheckNonce",
        "CheckWeight",
        "ChargeTransactionPayment"
      ]
    }
  }